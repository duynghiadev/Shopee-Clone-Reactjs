✅✅✅✅ Đây là docs tự research google và chat-GPT ✅✅✅✅

## RTK Query là gì ?

- `RTK Query` là một thư viện được cung cấp bởi Redux Toolkit (RTK) và được sử dụng để quản lý trạng thái (`state`) và gửi các yêu cầu mạng (network requests) trong ứng dụng Redux. Nó cung cấp một cách đơn giản và mạnh mẽ để thực hiện các hoạt động liên quan đến API như truy vấn dữ liệu, thay đổi dữ liệu, `caching`, `invalidation`, và nhiều tính năng khác.

- Với `RTK Query`, bạn có thể định nghĩa các endpoints (điểm cuối) API thông qua việc tạo ra các API slice. Các API slice này định nghĩa các hành động (actions) và reducers tương ứng để thực hiện các yêu cầu mạng và quản lý trạng thái dữ liệu liên quan.

- `RTK Query` tự động xử lý việc tạo ra các hàm truy vấn và mutations dựa trên các endpoints được định nghĩa trong API slice. Nó cung cấp các phương thức tiện ích để thực hiện các hoạt động như lấy dữ liệu từ API, cập nhật dữ liệu, xóa dữ liệu, và nhiều hoạt động khác một cách dễ dàng và nhất quán.

- Một số tính năng nổi bật của `RTK Query` bao gồm:

  - `Caching`: Tự động quản lý bộ nhớ cache để lưu trữ dữ liệu trước đó và giảm số lượng yêu cầu mạng lặp lại.
  - `Invalidation`: Tự động gọi API lại khi có các thay đổi liên quan đến dữ liệu. Nó là một hàm có tên là `invalidatesTags`
  - `Refetching`: Cho phép tự động gửi lại các yêu cầu mạng khi ứng dụng được tập trung hoặc kết nối mạng lại.
  - `Pagination`: Hỗ trợ trang bằng cách tự động quản lý và lấy dữ liệu phân trang từ API.
  - `TypeScript-friendly`: Hỗ trợ tốt TypeScript với kiểu dữ liệu mạnh mẽ và IntelliSense.

=> Tóm lại: `RTK Query` giúp giảm đáng kể công việc lặp lại, giảm thiểu code boilerplate và cung cấp một cách tiếp cận hiệu quả cho việc làm việc với API trong Redux.

## mutation trong ngữ cảnh redux thì nó có nghĩa là gì ?

- Trong ngữ cảnh của Redux, thuật ngữ "`mutation`" được sử dụng để chỉ các hành động thay đổi trạng thái (`state`) của ứng dụng. Trong Redux, các `mutations` thường được thực hiện thông qua các `action` và `reducers`.

- Trong Redux, một `mutation` xảy ra khi một `action` được gửi đi để thay đổi trạng thái (`state`) của ứng dụng. Các `action` đại diện cho sự kiện (`event`) hoặc hành động được kích hoạt trong ứng dụng, chẳng hạn như người dùng nhấp vào một nút, gửi một biểu mẫu, hoặc nhận dữ liệu từ API. Mỗi `action` được gửi đi sẽ kích hoạt các `reducers` để xác định cách thay đổi trạng thái (`state`) của ứng dụng dựa trên `action` đó.

- `Reducers` trong Redux có nhiệm vụ xử lý các `action` và tạo ra một phiên bản mới của trạng thái (`state`) dựa trên `action` đó. Những thay đổi này có thể được coi là các `mutations` vì chúng thay đổi trạng thái hiện tại thành trạng thái mới, nhưng theo cách tiếp cận không thay đổi (`immutable`) của Redux. Thay vì sửa đổi trực tiếp trạng thái hiện tại, Redux khuyến khích việc tạo ra một bản sao của trạng thái hiện tại và thực hiện các thay đổi trên bản sao đó để tạo ra một trạng thái mới.

=> 🚀📌 Vì vậy, trong ngữ cảnh Redux, "`mutation`" thường được sử dụng để chỉ các hành động thay đổi trạng thái của ứng dụng thông qua việc sử dụng `action` và `reducer` để tạo ra một trạng thái mới (`new state`).

## code boilerplate trong lập trình được gọi là gì ?

- Trong lập trình, "boilerplate" (bản mẫu) là các đoạn mã hoặc cấu trúc mã được sử dụng nhiều lần trong các dự án phần mềm khác nhau. Các đoạn mã boilerplate thường được dùng để thực hiện các công việc cơ bản và phổ biến, như khởi tạo một ứng dụng, cấu hình môi trường, xử lý lỗi, định nghĩa các hàm và lớp, và nhiều tác vụ khác.

- Boilerplate code thường không cung cấp giá trị đáng kể cho chức năng của ứng dụng, mà chỉ là nền tảng cho các phần mềm phức tạp hơn. Việc sử dụng boilerplate code có thể giúp đơn giản hóa và tăng tốc độ phát triển phần mềm, vì các lập trình viên không cần phải viết lại các đoạn mã cơ bản mỗi khi tạo một ứng dụng mới.

- Ví dụ, trong web development, các boilerplate code phổ biến như "create-react-app" cho React, "Express-generator" cho Node.js và "Ruby on Rails" cho Ruby. Các framework này cung cấp các đoạn mã boilerplate để giúp tạo nên một ứng dụng web hoàn chỉnh một cách nhanh chóng và dễ dàng hơn.

=> Tóm lại, code boilerplate nó cũng chỉ code thừa, code không có giá trị.

## Lý do RTK Query xuất hiện ? RTK Query giúp chúng ta làm những việc gì ?

- ✅ RTK Query xuất hiện với mục đích giải quyết những thách thức và vấn đề thường gặp khi làm việc với API trong Redux. Dưới đây là một số lý do và lợi ích của việc sử dụng RTK Query:

  - `Giảm code boilerplate`: RTK Query giúp giảm số lượng code boilerplate cần phải viết để thực hiện các yêu cầu mạng, quản lý trạng thái và `caching`. Nó tự động tạo ra các hàm truy vấn và `mutations` dựa trên cấu hình `endpoints`, giúp tiết kiệm thời gian và công sức.

  - `Quản lý trạng thái dễ dàng`: RTK Query tự động quản lý trạng thái của dữ liệu liên quan đến API, bao gồm việc lưu trữ và cập nhật dữ liệu. Nó cung cấp các cơ chế như `caching`, `invalidation` và `refetching` để đảm bảo rằng dữ liệu được duy trì và cập nhật một cách nhất quán.

  - `Tích hợp tốt với Redux`: RTK Query được xây dựng trên cơ sở của Redux và tích hợp một cách mượt mà với các công cụ và khái niệm của Redux như `actions`, `reducers` và `store`. Nó tận dụng các lợi ích của Redux như kiểm soát trạng thái dễ dàng, gỡ lỗi và theo dõi thay đổi.

  - `Tích hợp TypeScript-friendly`: RTK Query hỗ trợ tốt TypeScript với kiểu dữ liệu mạnh mẽ và IntelliSense. Nó cung cấp các kiểu dữ liệu đúng đắn cho các truy vấn và mutations, giúp giảm thiểu lỗi và cung cấp trải nghiệm phát triển an toàn và dễ dàng.

  - `Cung cấp tính năng mạnh mẽ`: RTK Query đi kèm với nhiều tính năng hữu ích như `pagination`, `sorting`, `filtering` và tự động gửi lại yêu cầu mạng khi ứng dụng được tập trung hoặc kết nối mạng lại. Nó cung cấp một cách tiếp cận tiện lợi và mạnh mẽ cho việc làm việc với API.

=> 🚀📌 Tóm lại, `RTK Query` giúp giảm thiểu công việc lặp lại, cung cấp quản lý trạng thái dễ dàng, tích hợp tốt với Redux và cung cấp nhiều tính năng mạnh mẽ để làm việc với API. Nó tạo ra một cách tiếp cận hiệu quả và hiệu quả hơn cho việc quản lý dữ liệu và tương tác với các dịch vụ mạng trong ứng dụng Redux.

- ✅ Ngoài những tính năng chính đã được đề cập, RTK Query còn cung cấp một số tính năng khác nhằm tối ưu hóa và đơn giản hóa quá trình làm việc với API. Dưới đây là một số tính năng quan trọng khác của RTK Query:

- `Auto-Generated API Slices`: RTK Query tự động tạo ra các API slices (đoạn code để thao tác với dữ liệu từ API) dựa trên cấu hình endpoints. Các API slices này giúp giảm thiểu code boilerplate và tự động xử lý các thao tác CRUD (`Create`, `Read`, `Update`, `Delete`) liên quan đến dữ liệu từ API.

- `Data Normalization`: RTK Query hỗ trợ việc normalize dữ liệu tự động. Điều này đảm bảo rằng các mục dữ liệu được lưu trữ và sử dụng chung một cách hiệu quả, tránh việc lưu trữ dữ liệu trùng lặp và tối ưu hóa hiệu suất.

- `Pagination`: RTK Query hỗ trợ tính năng phân trang dữ liệu từ API. Nó cung cấp các phương thức và kiểu dữ liệu để dễ dàng thao tác với các trang dữ liệu và tự động tải các trang mới khi cần thiết.

- `Data Invalidation`: RTK Query có khả năng tự động xác định khi dữ liệu từ API đã bị lỗi thời hoặc không còn đúng. Khi dữ liệu bị hết hạn, nó sẽ tự động gửi yêu cầu mới để cập nhật dữ liệu và duy trì tính nhất quán. Nói một cách dễ hiểu hơn nó có nghĩa là: Tự động gọi API lại khi có các thay đổi liên quan đến dữ liệu. Nó là một hàm có tên là `invalidatesTags`

- `Polling`: RTK Query hỗ trợ tính năng polling, cho phép tự động gửi yêu cầu tới API theo khoảng thời gian nhất định. Điều này hữu ích trong các trường hợp cần cập nhật dữ liệu liên tục hoặc theo dõi sự thay đổi từ phía server.

- `TypeScript Support`: RTK Query được thiết kế để tương thích tốt với TypeScript. Nó cung cấp các kiểu dữ liệu mạnh mẽ để giúp phát hiện lỗi và cung cấp trải nghiệm phát triển an toàn và dễ dàng.

=> 🚀📌 Tóm lại, `RTK Query` không chỉ cung cấp các tính năng cơ bản để làm việc với API mà còn đi kèm với nhiều tính năng khác nhằm tối ưu hóa quá trình làm việc và đơn giản hóa việc quản lý dữ liệu trong ứng dụng Redux.

## RTK Query dùng để sử dụng trong những trường hợp nào ?

- `RTK Query` được thiết kế để sử dụng trong các trường hợp sau:

- `Truy vấn dữ liệu từ API`: RTK Query giúp bạn truy vấn dữ liệu từ API một cách dễ dàng và hiệu quả. Bạn có thể định nghĩa các endpoint API và sử dụng các hàm tạo truy vấn để lấy dữ liệu từ server.

- `Quản lý trạng thái dữ liệu`: RTK Query tự động quản lý trạng thái dữ liệu trên client-side. Nó lưu trữ và cập nhật dữ liệu từ server, cho phép bạn truy cập vào dữ liệu đã được cache mà không cần gửi yêu cầu lại.

- `Tích hợp với Redux`: RTK Query được xây dựng trên Redux và tích hợp hoàn hảo với Redux store. Nó giúp bạn tổ chức và quản lý dữ liệu trong store Redux một cách dễ dàng và theo cách tiếp cận kiểu Redux Toolkit.

- `Caching data`: RTK Query cung cấp tính năng caching dữ liệu tự động.

  - Có nghĩa là RTK Query có khả năng tự động lưu trữ dữ liệu đã được truy vấn từ API. Khi bạn thực hiện một truy vấn dữ liệu từ API bằng RTK Query, nó sẽ tự động lưu trữ kết quả của truy vấn đó trong bộ nhớ cache.

  - Khi bạn thực hiện truy vấn tương tự sau đó, RTK Query sẽ kiểm tra xem dữ liệu đã có trong cache hay chưa. Nếu dữ liệu đã tồn tại trong cache và chưa hết hạn, RTK Query sẽ trả về dữ liệu từ cache mà không cần gửi yêu cầu mới đến API. Điều này giúp giảm số lượng yêu cầu gửi đi và cải thiện hiệu suất ứng dụng.

  - Tính năng caching tự động của RTK Query cũng đi kèm với việc quản lý tính nhất quán dữ liệu. Khi có sự thay đổi từ phía server, RTK Query sẽ tự động cập nhật dữ liệu trong cache để đảm bảo dữ liệu được cập nhật và đúng đắn.

  - Với tính năng caching này, RTK Query giúp tối ưu việc truy vấn dữ liệu từ API và cung cấp trải nghiệm ứng dụng mượt mà hơn cho người dùng.

- `invalidation data`:

  - Tự động gọi API lại khi có các thay đổi liên quan đến dữ liệu. Nó là một hàm có tên là `invalidatesTags`

  - Nó cũng hỗ trợ invalidation tự động khi dữ liệu hết hạn hoặc không còn đúng.

  - RTK Query cung cấp tính năng invalidation tự động khi dữ liệu hết hạn hoặc không còn đúng. Khi bạn thực hiện một truy vấn dữ liệu từ API bằng RTK Query, nó sẽ tự động ghi lại thời gian khi dữ liệu được truy vấn. Sau một khoảng thời gian xác định, RTK Query sẽ xem xét dữ liệu đã hết hạn hay không.

  - Nếu dữ liệu đã hết hạn, RTK Query sẽ tự động gửi yêu cầu mới đến API để cập nhật dữ liệu mới nhất. Điều này đảm bảo rằng dữ liệu trong cache luôn được cập nhật và không trở nên lỗi thời.

  - Ngoài ra, RTK Query cũng hỗ trợ việc xác định tự động khi dữ liệu không còn đúng. Khi có sự thay đổi từ phía server, ví dụ như thông tin bị thay đổi hoặc bản ghi bị xóa, RTK Query sẽ tự động ghi nhận sự thay đổi này và cập nhật dữ liệu trong cache. Điều này đảm bảo rằng dữ liệu được duy trì trong trạng thái chính xác và tương thích với trạng thái thực tế từ phía server.

  - Tính năng invalidation tự động của RTK Query giúp đảm bảo rằng dữ liệu trong ứng dụng của bạn luôn được cập nhật và đúng đắn, đồng thời giảm tải cho server bằng cách chỉ cập nhật dữ liệu khi cần thiết.

- `Tích hợp với TypeScript`: RTK Query được thiết kế để tương thích tốt với TypeScript, cung cấp các kiểu dữ liệu mạnh mẽ để giúp phát hiện lỗi và cung cấp trải nghiệm phát triển an toàn và dễ dàng.

=> 🚀📌 Tóm lại, `RTK Query` là một công cụ mạnh mẽ để làm việc với API trong Redux. Nó giúp bạn truy vấn dữ liệu, quản lý trạng thái dữ liệu, `caching`, `invalidation` và tích hợp tốt với `Redux` và `TypeScript`.

## RTK Query xịn đến cở nào ?

- RTK Query được xem là một thư viện xịn trong việc quản lý truy vấn dữ liệu trong ứng dụng Redux. Dưới đây là một số điểm nổi bật của RTK Query:

  - `Tích hợp dễ dàng`: RTK Query được thiết kế để tích hợp trực tiếp với Redux và Redux Toolkit. Bạn có thể sử dụng RTK Query mà không cần phải cài đặt các thư viện ngoài khác.

  - `Cú pháp đơn giản`: RTK Query cung cấp cú pháp đơn giản và rõ ràng để định nghĩa các truy vấn dữ liệu và mutations. Bạn có thể sử dụng các `builder functions` để xác định các endpoint API và quy định các hoạt động CRUD một cách dễ dàng.

  - `Tính năng tự động`: RTK Query cung cấp nhiều tính năng tự động như `caching` dữ liệu, `invalidation` dữ liệu, và `refetching` tự động khi ứng dụng có sự thay đổi hoặc được focus. Điều này giúp giảm thiểu việc lập trình thủ công và tối ưu hiệu năng ứng dụng.

  - `Tương thích với REST và GraphQL`: RTK Query hỗ trợ cả REST và GraphQL và cho phép bạn xác định các truy vấn và mutations dựa trên cả hai phương thức này. Bạn có thể sử dụng RTK Query để giao tiếp với các `API` dựa trên `REST` hoặc `GraphQL` một cách dễ dàng.

  - `Tích hợp với DevTools`: RTK Query tích hợp sẵn với `Redux DevTools`, cho phép bạn theo dõi và gỡ lỗi các hoạt động truy vấn và mutations một cách dễ dàng.

=> 🚀📌 Tóm lại, `RTK Query` được đánh giá là một thư viện xịn đến mức đảm bảo tính đơn giản, hiệu năng cao và tích hợp tốt với Redux, giúp giảm thiểu công việc lặp lại và tối ưu quá trình quản lý truy vấn dữ liệu trong ứng dụng Redux của bạn.

## Khi sử dụng RTK Query nó có khác gì so với createAsyncThunk ?

- Khi sử dụng RTK Query, có một số `khác biệt` so với việc sử dụng `createAsyncThunk` trong Redux Toolkit:

  - `Tự động tạo các action và reducer`: RTK Query tự động tạo các action và reducer cho các truy vấn và mutations, giúp giảm bớt công việc lặp lại khi tạo các action và reducer thủ công như khi sử dụng `createAsyncThunk`.

  - `Tích hợp sẵn với Redux Toolkit`: RTK Query được thiết kế để tích hợp sẵn với Redux Toolkit, mang đến sự thuận tiện và tương thích với cách Redux Toolkit xử lý `store` và `middleware`.

  👉 Câu này nói về việc RTK Query được thiết kế để tích hợp sẵn với Redux Toolkit. Điều này có nghĩa là RTK Query được xây dựng để hoạt động tốt với Redux Toolkit và tận dụng các tính năng và cấu trúc của Redux Toolkit.

  👉 Khi sử dụng Redux Toolkit, chúng ta thường sử dụng `configureStore` để tạo `store` và sử dụng các `middleware` như `redux-thunk` hoặc `redux-saga` để xử lý các side effects. RTK Query cung cấp một `middleware` riêng để xử lý các truy vấn và `mutations` từ API, và nó đã được tích hợp sẵn với Redux Toolkit. Điều này đồng nghĩa rằng chúng ta có thể sử dụng RTK Query như một phần của Redux Toolkit mà không cần cấu hình hoặc tích hợp thêm nhiều thư viện hay `middleware` khác.

  👉 Việc tích hợp sẵn giữa RTK Query và Redux Toolkit mang lại sự thuận tiện và tương thích cho việc quản lý trạng thái ứng dụng và xử lý các tác động phụ trong một cấu trúc duy nhất. Chúng ta không cần lo lắng về việc cấu hình Redux store, xử lý `middleware` hoặc tích hợp các thư viện khác, vì RTK Query đã được tối ưu và đồng bộ hoá tốt với Redux Toolkit.

  - `Hỗ trợ caching tự động`: RTK Query cung cấp tính năng `caching` tự động, giúp lưu trữ kết quả truy vấn và sử dụng lại chúng mà không cần gửi lại yêu cầu mạng. Điều này giúp cải thiện hiệu suất ứng dụng và giảm tải cho server.

  - `Tự động xử lý invalidation`: RTK Query hỗ trợ `invalidation` tự động khi dữ liệu hết hạn hoặc không còn đúng. Khi có dữ liệu mới được cập nhật, RTK Query sẽ tự động cập nhật `cache` và thông báo cho các thành phần (`component`) sử dụng dữ liệu để cập nhật giao diện. Nói một cách dễ hiểu nó là: Tự động gọi API lại khi có các thay đổi liên quan đến dữ liệu. Nó là một hàm có tên là `invalidatesTags`

  - `Hỗ trợ các tính năng tiện ích khác`: RTK Query cung cấp các tính năng tiện ích như `pagination`, `polling` (tự động gửi yêu cầu liên tục), `refetching` (gửi lại yêu cầu khi có sự tương tác từ người dùng), và nhiều tính năng khác giúp quản lý dữ liệu từ API dễ dàng hơn.

  👉 Cách thức polling có thể được thực hiện bằng cách sử dụng hàm lặp (looping) hoặc sử dụng các cơ chế như setTimeout hoặc setInterval để gửi yêu cầu định kỳ. Khi dữ liệu hết hạn hoặc có sự thay đổi, ứng dụng sẽ gửi lại yêu cầu để lấy thông tin mới.

  👉 Tuy nhiên, cần lưu ý rằng việc sử dụng polling có thể gây tốn tài nguyên mạng và hiệu năng ứng dụng. Nếu không cần thiết, nên xem xét sử dụng các phương pháp khác như long polling hoặc sự kiện đẩy (push events) để giảm tải và tối ưu hóa quá trình cập nhật dữ liệu.

=> 🚀📌 Tóm lại, `RTK Query` cung cấp một giải pháp toàn diện và tiện lợi cho việc quản lý truy vấn và mutations từ API, giúp giảm thiểu công việc lặp lại, tối ưu hiệu suất và cung cấp các tính năng mạnh mẽ như `caching` và `invalidation`.

## Ưu điểm và khuyết điểm khi sử dụng RTK Query ?

- ❌❌❌❌ Ưu điểm ❌❌❌❌

- ✅✅ Khi sử dụng RTK Query, bạn sẽ tận hưởng một số ưu điểm sau:

  - `Dễ sử dụng`: RTK Query cung cấp cú pháp đơn giản và gọn gàng để tạo và quản lý các truy vấn và mutations từ API. Nó giảm thiểu khối lượng mã và đơn giản hóa quy trình lập trình.

  - `Tích hợp sẵn với Redux Toolkit`: RTK Query được thiết kế để tích hợp sẵn với Redux Toolkit, một công cụ mạnh mẽ cho quản lý trạng thái ứng dụng. Điều này đảm bảo sự tương thích và tích hợp dễ dàng với Redux store và `middleware`.

  - `Tính năng caching tự động`: RTK Query cung cấp tính năng `caching` dữ liệu tự động. Khi bạn thực hiện một truy vấn, kết quả sẽ được lưu trữ trong bộ nhớ `cache`, và các truy vấn tương tự sau đó sẽ sử dụng dữ liệu đã được lưu trữ từ `cache` thay vì gửi yêu cầu mới đến API. Điều này giúp tiết kiệm tài nguyên mạng và tăng tốc độ phản hồi.

  - `Invalidations tự động`: RTK Query hỗ trợ invalidations tự động. Khi dữ liệu trong `cache` hết hạn hoặc không còn đúng, RTK Query sẽ tự động làm mới dữ liệu bằng cách gửi yêu cầu mới đến API. Điều này đảm bảo rằng dữ liệu được cập nhật và chính xác.

  - `Xử lý side effects tự động`: RTK Query giúp tự động xử lý các side effects như xử lý lỗi, tái truy vấn khi mất kết nối, hoặc thực hiện các hành động phụ liên quan đến dữ liệu. Bạn không cần phải viết nhiều mã xử lý tương tác với API, RTK Query sẽ tự động quản lý và xử lý các tác vụ phụ liên quan.

  - `Hỗ trợ TypeScript`: RTK Query hỗ trợ tốt `TypeScript`, cho phép bạn kiểm tra kiểu dữ liệu và phát hiện lỗi một cách dễ dàng. Cú pháp mạnh mẽ của RTK Query cũng giúp kiểm soát và định nghĩa rõ ràng các kiểu dữ liệu.

=> 🚀📌 Tổng thể, RTK Query mang lại nhiều ưu điểm cho việc quản lý trạng thái ứng dụng và tương tác với API, giúp bạn giảm thiểu công sức lập trình và tăng hiệu suất ứng dụng.

- ❌❌❌❌ Khuyết điểm ❌❌❌❌

- ✅✅ Mặc dù RTK Query có nhiều ưu điểm, nhưng cũng có một số khuyết điểm sau:

  - `Học hỏi ban đầu`: RTK Query có một cú pháp riêng và yêu cầu một giai đoạn học hỏi ban đầu để hiểu cách sử dụng và cấu hình chính xác. Điều này có thể làm tăng độ dốc học tập và tạo ra một thời gian thích ứng ban đầu.

  - `Giới hạn tùy chỉnh`: Mặc dù RTK Query cung cấp nhiều tính năng mạnh mẽ, có thể có một số trường hợp sử dụng đặc biệt mà yêu cầu tùy chỉnh phức tạp hơn. Trong những trường hợp như vậy, việc tùy chỉnh RTK Query có thể trở nên khó khăn hoặc hạn chế.

  - `Phụ thuộc vào Redux Toolkit`: RTK Query được tích hợp sẵn với Redux Toolkit và sử dụng Redux store và `middleware`. Điều này có nghĩa là nếu bạn không sử dụng Redux hoặc không muốn sử dụng Redux Toolkit, việc tích hợp RTK Query vào dự án hiện có có thể gặp một số khó khăn.

  - `Hạn chế với các hệ thống API phức tạp`: RTK Query được thiết kế cho việc làm việc với các hệ thống API `RESTful` đơn giản. Đối với các hệ thống API phức tạp hơn, có thể cần phải thực hiện tùy chỉnh và mở rộng RTK Query để đáp ứng các yêu cầu cụ thể.

  - `Hiệu suất không linh hoạt`: Mặc dù RTK Query cung cấp tính năng caching dữ liệu tự động, hiệu suất không linh hoạt trong một số trường hợp đặc biệt. Điều này có thể xảy ra khi dữ liệu thay đổi thường xuyên hoặc khi yêu cầu truy vấn phức tạp với số lượng lớn dữ liệu.

=> 🚀📌 Tuy nhiên, các khuyết điểm này thường được cân nhắc và quản lý tốt trong hầu hết các dự án, và ưu điểm của RTK Query vẫn được đánh giá cao trong việc phát triển ứng dụng.

## RTK Query được nhiều developer ưa chuộng khi làm các dự án không ?

- RTK Query đã nhận được sự ưa chuộng từ nhiều nhà phát triển khi làm các dự án vì các lý do sau:

  - Dễ sử dụng: RTK Query được thiết kế để đơn giản hóa việc truy vấn và quản lý dữ liệu từ API. Nó cung cấp một cú pháp rõ ràng và dễ hiểu, giúp giảm độ phức tạp của việc xử lý truy vấn dữ liệu.

  - Tích hợp sẵn với Redux Toolkit: RTK Query tích hợp tốt với Redux Toolkit, mang lại sự thuận tiện và tương thích với cách Redux Toolkit xử lý `store` và `middleware`. Điều này giúp giảm độ phức tạp của việc tích hợp và quản lý trạng thái ứng dụng.

  - Tính năng mạnh mẽ: RTK Query cung cấp nhiều tính năng hữu ích như caching tự động, `refetching`, `invalidation`, `pagination`, `prefetching`, và nhiều hơn nữa. Các tính năng này giúp giảm thời gian và công sức trong việc xử lý dữ liệu từ API.

  - Tích hợp dữ liệu dễ dàng: RTK Query cho phép bạn định nghĩa các endpoint và truy vấn dữ liệu thông qua các tệp slice, giúp tổ chức mã và quản lý dữ liệu một cách có tổ chức. Nó cũng cho phép bạn tùy chỉnh các truy vấn dựa trên nhu cầu cụ thể của ứng dụng.

  - Tích hợp tốt với UI frameworks: RTK Query có khả năng tích hợp tốt với các framework UI phổ biến như React, Angular và Vue. Điều này giúp cho việc phát triển ứng dụng dễ dàng và linh hoạt hơn trong môi trường phát triển phổ biến.

=> 🚀📌 Tóm lại, RTK Query đã trở thành một lựa chọn phổ biến cho nhiều nhà phát triển khi làm các dự án, nhờ vào tính đơn giản, tích hợp với Redux Toolkit và các tính năng mạnh mẽ giúp giảm công sức và thời gian trong việc quản lý dữ liệu từ API.

## Cho ví dụ về RTK Query ?

- Dưới đây là một ví dụ đơn giản về việc sử dụng RTK Query trong một ứng dụng React để truy vấn và quản lý dữ liệu từ một API:

- Đầu tiên, chúng ta cần cài đặt các thư viện cần thiết:

```jsx
npm install @reduxjs/toolkit react-redux @reduxjs/toolkit/query
```

- Tiếp theo, chúng ta sẽ định nghĩa một slice sử dụng RTK Query để truy vấn dữ liệu từ API. Ví dụ sau đây sử dụng slice để lấy danh sách người dùng từ API:

✅✅✅✅ Đoạn code 1: ✅✅✅✅

```jsx
// user.slice.js

import { createSlice } from "@reduxjs/toolkit";
import { createAsyncThunk } from "@reduxjs/toolkit/query";

// Định nghĩa truy vấn
export const fetchUsers = createAsyncThunk("users/fetchUsers", async () => {
  const response = await fetch("/api/users");
  const data = await response.json();
  return data;
});

// Định nghĩa slice
const userSlice = createSlice({
  name: "users",
  initialState: [],
  reducers: {},
  extraReducers: (builder) => {
    builder.addCase(fetchUsers.fulfilled, (state, action) => {
      return action.payload;
    });
  },
});

export default userSlice.reducer;
```

✅✅✅✅❌❌ Dưới đây là phân tích và giải thích từng đoạn code trên ❌❌✅✅✅✅

```jsx
import { createSlice } from "@reduxjs/toolkit";
import { createAsyncThunk } from "@reduxjs/toolkit/query";
```

- ✅ Đoạn code trên có ý nghĩa:

- Trong đoạn code trên, chúng ta sử dụng hai phương thức được cung cấp bởi thư viện `@reduxjs/toolkit` để tạo slice và truy vấn bất đồng bộ (async).

- `createSlice`: Đây là một hàm được cung cấp bởi Redux Toolkit để tạo ra một slice trong Redux. Slice là một phần của store Redux, chứa các reducers và actions liên quan đến một phần của ứng dụng. Chúng ta import `createSlice` từ `@reduxjs/toolkit` để tạo slice mới.

- `createAsyncThunk`: Đây là một hàm cung cấp bởi Redux Toolkit để tạo ra một action async được xử lý bởi Redux Thunk middleware. Hàm này nhận vào một tên định danh cho action và một hàm async thực hiện các công việc bất đồng bộ, ví dụ như gọi API. Hàm này trả về một action creator, cho phép chúng ta gửi các action async này và xử lý kết quả của chúng trong reducers.

=> Tổng kết, đoạn code trên sử dụng createSlice để tạo một slice mới trong Redux và createAsyncThunk để tạo một action async được xử lý bởi Redux Thunk middleware. Đây là các hàm quan trọng trong Redux Toolkit giúp chúng ta dễ dàng quản lý state và xử lý các tác vụ bất đồng bộ trong ứng dụng Redux.

```jsx
export const fetchUsers = createAsyncThunk("users/fetchUsers", async () => {
  const response = await fetch("/api/users");
  const data = await response.json();
  return data;
});
```

- Trong đoạn code trên, chúng ta tạo một action async có tên là "`users/fetchUsers`" sử dụng `createAsyncThunk` từ Redux Toolkit. Action này được sử dụng để gửi một yêu cầu API đến đường dẫn "`/api/users`" để lấy danh sách người dùng.

- Khi action "users/fetchUsers" được gọi, Redux Thunk middleware sẽ bắt đầu xử lý action này. Trong hàm async được truyền vào `createAsyncThunk`, chúng ta sử dụng `fetch` để gửi một yêu cầu GET đến "`/api/users`" và đợi phản hồi từ server.

- Khi phản hồi được nhận, chúng ta sử dụng `response.json()` để chuyển đổi dữ liệu phản hồi từ định dạng `JSON` sang dạng đối tượng (`object`) của JavaScript. Kết quả dữ liệu JSON chuyển đổi được trả về từ hàm `async` và tự động trở thành `payload` của `action`.

- Các reducers của chúng ta có thể đăng ký để lắng nghe action "`users/fetchUsers`" và xử lý kết quả của nó. Khi `action` được `dispatch`, Redux Thunk middleware sẽ thực thi hàm `async` đã được truyền vào `createAsyncThunk` và cập nhật trạng thái của action dựa trên kết quả trả về từ hàm async.

- Điều này cho phép chúng ta gửi yêu cầu API một cách dễ dàng và xử lý kết quả một cách tự động trong Redux, giúp chúng ta quản lý trạng thái và tương tác với dữ liệu từ API một cách tiện lợi.

- Đoạn code trên sẽ tạo ra một action creator có tên `fetchUsers`, mà chúng ta có thể sử dụng để dispatch action này và xử lý kết quả trong reducers của chúng ta. Khi action này được dispatch, Redux Thunk middleware sẽ thực thi hàm `async` đã được truyền vào `createAsyncThunk` và cập nhật trạng thái của action dựa trên kết quả trả về từ hàm async.

❌❌❌❌ 👆👆👆 Lưu ý trong đoạn giải thích trên: 👆👆👆 ❌❌❌❌

- Trong đoạn giải thích code ở trên có đề cập đến từ `trạng thái của action`. Lưu ý đó không phải là payload của action. Chúng ta hãy tìm hiểu về nó là cái gì ?

- Trạng thái của action không phải là payload của action đó. Trạng thái của action chỉ đơn giản là một thuộc tính (property) của action, thường được sử dụng để biểu thị trạng thái của một công việc không đồng bộ (async).

- Khi sử dụng `createAsyncThunk`, Redux Toolkit tự động tạo ra các trạng thái cho action tương ứng với các trạng thái của công việc async: `pending`, `fulfilled`, và `rejected`. Các trạng thái này không phải là payload của action, mà là các thuộc tính của action để biểu thị trạng thái của công việc.

- Ví dụ, khi action `users/fetchUsers` được gọi, nó có thể có các trạng thái như sau:

- `users/fetchUsers/pending`: Được gửi khi công việc đang được thực hiện.
- `users/fetchUsers/fulfilled`: Được gửi khi công việc hoàn thành thành công, kèm theo payload là kết quả trả về từ hàm async.
- `users/fetchUsers/rejected`: Được gửi khi công việc bị từ chối hoặc lỗi xảy ra, kèm theo payload là thông tin lỗi.

=> Payload của action được chứa trong thuộc tính `payload` của action, không phải là trạng thái của action. Trạng thái của action được sử dụng để theo dõi quá trình thực hiện của công việc và thực hiện các xử lý phù hợp trong reducer.

```jsx
const userSlice = createSlice({
  name: "users",
  initialState: [],
  reducers: {},
  extraReducers: (builder) => {
    builder.addCase(fetchUsers.fulfilled, (state, action) => {
      return action.payload;
    });
  },
});
```

- Đoạn code trên định nghĩa một slice của Redux Toolkit có tên là "users" (name: "users"). Slice này sẽ quản lý trạng thái liên quan đến người dùng (users).

  - `initialState` định nghĩa trạng thái ban đầu của slice, ở đây là một mảng rỗng (initialState: []).
  - `reducers` là một đối tượng chứa các reducer (hàm xử lý action) tương ứng với các action được gửi đến slice. Trong ví dụ này, không có reducer nào được định nghĩa (reducers: {}), nên slice chỉ sử dụng reducers được tạo ra bởi `extraReducers`.
  - `extraReducers` là một hàm callback nhận vào một đối tượng builder, cho phép chúng ta xác định các reducer cho các action không thuộc reducers đã được định nghĩa trước đó. Trong ví dụ này, chỉ có một reducer được định nghĩa thông qua `builder.addCase`.
  - `builder.addCase` xác định một reducer cho một action cụ thể. Trong ví dụ này, reducer được xác định cho action `fetchUsers.fulfilled`, tức là khi action `fetchUsers` hoàn thành thành công.
  - Trong reducer, trạng thái hiện tại của slice (`state`) được cập nhật bằng payload của action (`action.payload`). Điều này có nghĩa là khi action `fetchUsers.fulfilled` được gửi và thành công, trạng thái của slice "users" sẽ được cập nhật thành dữ liệu người dùng được trả về từ hàm `fetchUsers`.

- Với đoạn code trên, khi action `fetchUsers.fulfilled` được gọi và hoàn thành thành công, trạng thái của slice "users" sẽ được cập nhật với dữ liệu người dùng mới.

```jsx
export default userSlice.reducer;
```

- Đoạn code trên xuất ra reducer của slice được tạo bởi `createSlice`. `createSlice` trả về một đối tượng slice gồm các reducer đã được tự động tạo ra dựa trên các hành động đã được xác định trong `reducers` và `extraReducers`.

- Trong trường hợp này, `userSlice.reducer` là reducer được tạo ra bởi slice `userSlice`. Bằng cách xuất reducer này, chúng ta có thể sử dụng nó để kết hợp với các reducer khác và tạo ra store trong Redux.

✅✅✅✅ Đoạn code 2: ✅✅✅✅

- Sau đó, chúng ta cần khai báo RTK Query API để sử dụng trong ứng dụng. Ví dụ sau đây khai báo một API để lấy danh sách người dùng:

```jsx
// api.js

import { createApi, fetchBaseQuery } from "@reduxjs/toolkit/query";

export const userApi = createApi({
  reducerPath: "userApi",
  baseQuery: fetchBaseQuery({ baseUrl: "/api" }),
  endpoints: (builder) => ({
    getUsers: builder.query({
      query: () => "users",
    }),
  }),
});

export const { useGetUsersQuery } = userApi;
```

✅✅✅✅❌❌ Dưới đây là phân tích và giải thích từng đoạn code trên ❌❌✅✅✅✅

```jsx
import { createApi, fetchBaseQuery } from "@reduxjs/toolkit/query";
```

- Đoạn code trên sử dụng `createApi` và `fetchBaseQuery` từ Redux Toolkit Query để tạo ra một API client. `createApi` là một hàm giúp xây dựng API client cho việc thực hiện các yêu cầu truy vấn dữ liệu từ API.

- `fetchBaseQuery` là một trong những phương thức mặc định được cung cấp bởi Redux Toolkit Query (`RTK Query`) để thực hiện các yêu cầu HTTP thông qua `fetch`. Nó là một fetch base query function cho phép bạn tùy chỉnh và cấu hình các yêu cầu HTTP trước khi gửi lên server.

- Khi sử dụng `createApi` và `fetchBaseQuery` kết hợp, chúng ta có thể xây dựng một API client với các phương thức truy vấn dữ liệu như `query`, `mutation`, và `subscription` để gửi các yêu cầu tương ứng đến server.

```jsx
export const userApi = createApi({
  reducerPath: "userApi",
  baseQuery: fetchBaseQuery({
    baseUrl: "/api",
  }),
  endpoints: (builder) => ({
    getUsers: builder.query({
      query: () => "users",
    }),
  }),
});
```

- Đoạn code trên sử dụng `createApi` từ Redux Toolkit Query để tạo một API client cho việc truy vấn dữ liệu từ API.

- `reducerPath` là tên của reducer được tạo ra bởi API client, sẽ được sử dụng trong việc đăng ký reducer với Redux store.

- `baseQuery` là một fetch base query function được cung cấp bởi Redux Toolkit Query. Trong ví dụ này, `fetchBaseQuery` được cấu hình với `baseUrl` là `"/api"` trong những trường hợp khác có `api từ server` thì `baseUrl` là (http://localhost:4000/), đây là đường dẫn gốc mà tất cả các yêu cầu truy vấn sẽ được gửi đến.

- `endpoints` là một hàm callback nhận vào một đối tượng `builder`, được sử dụng để định nghĩa các endpoints cho API client. Trong ví dụ này, chỉ có một endpoint là `getUsers` bên trong API client. Endpoint này được định nghĩa dưới dạng một query.

  - `builder.query()` là một phương thức của đối tượng `builder` để định nghĩa một query endpoint.
  - Trong trường hợp này, query endpoint `getUsers` không có tham số truyền vào và sẽ gửi một yêu cầu truy vấn dữ liệu đến đường dẫn `"users"`.
  - Hàm callback truyền vào `query` trả về giá trị là `"users"`, đại diện cho đường dẫn của yêu cầu truy vấn dữ liệu.
  - Khi sử dụng API client và gọi `getUsers`, nó sẽ gửi một yêu cầu truy vấn dữ liệu đến đường dẫn `"users"` và trả về kết quả của yêu cầu này.

- Kết quả của việc sử dụng `createApi` là một API client object có thể được sử dụng để gửi các yêu cầu truy vấn dữ liệu từ server thông qua các endpoints đã được định nghĩa.

```jsx
export const { useGetUsersQuery } = userApi;
```

❌❌❌❌ Lưu ý: hãy hiểu rõ chỗ này nhé !!! ❌❌❌❌

- Đúng là trong đoạn code trên không có định nghĩa `useGetUsersQuery` trực tiếp. Thực tế, `useGetUsersQuery` được tạo tự động bởi RTK Query khi chúng ta sử dụng `builder.query` để định nghĩa endpoint `getUsers`.

- Khi chúng ta sử dụng `builder.query` để định nghĩa một endpoint, RTK Query sẽ tự động tạo ra một hook dựa trên tên của endpoint và định nghĩa của nó. Trong trường hợp này, vì chúng ta đã định nghĩa endpoint có tên là `getUsers`, RTK Query sẽ tự động tạo ra hook `useGetUsersQuery` để sử dụng.

- Do đó, khi chúng ta sử dụng destructuring assignment như `export const { useGetUsersQuery } = userApi;`, nó sẽ giúp chúng ta truy cập trực tiếp vào hook `useGetUsersQuery` đã được tạo ra bởi RTK Query, mà không cần phải định nghĩa nó một cách rõ ràng trong mã nguồn của chúng ta.

- Đoạn code trên định nghĩa một hàm hook có tên là `useGetUsersQuery` thông qua API client `userApi`.

  - `useGetUsersQuery` là một hàm hook được tạo tự động bởi RTK Query dựa trên endpoint `getUsers` mà chúng ta đã định nghĩa trước đó.
  - Khi sử dụng `useGetUsersQuery`, ta có thể gọi nó trong các thành phần React để thực hiện yêu cầu truy vấn dữ liệu và lấy kết quả trả về từ API server.
  - Hàm `useGetUsersQuery` sẽ tự động quản lý trạng thái yêu cầu chẳng hạn như (loading, error, data) và cung cấp các giá trị liên quan cho chúng, cho phép chúng ta dễ dàng sử dụng kết quả truy vấn trong thành phần React mà không cần phải viết nhiều mã xử lý tùy chỉnh.

✅✅✅✅ Đoạn code 3: ✅✅✅✅

- Tiếp theo, chúng ta cần cấu hình store Redux và kết nối API của chúng ta:

```jsx
// store.js

import { configureStore } from "@reduxjs/toolkit";
import { userApi } from "./api";
import userReducer from "./user.slice";

export const store = configureStore({
  reducer: {
    users: userReducer,
    [userApi.reducerPath]: userApi.reducer,
  },
  middleware: (getDefaultMiddleware) =>
    getDefaultMiddleware().concat(userApi.middleware),
});

export default store;
```

✅✅✅✅❌❌ Dưới đây là phân tích và giải thích từng đoạn code trên ❌❌✅✅✅✅

```jsx
import { configureStore } from "@reduxjs/toolkit";
import { userApi } from "./api";
import userReducer from "./user.slice";
```

- Đoạn code trên có mục đích cấu hình Redux store và kết hợp các phần cần thiết để sử dụng RTK Query.

- `configureStore` là một hàm được cung cấp bởi Redux Toolkit để tạo Redux store. Nó nhận vào một đối tượng cấu hình với các thuộc tính như `reducer`, `middleware`, `preloadedState`, và các tùy chọn khác.

- `userApi` được import từ module `./api` và là một instance của API được tạo ra bởi RTK Query thông qua hàm createApi. Đối tượng này định nghĩa các endpoints để gửi các yêu cầu liên quan đến người dùng (ví dụ: `getUsers`).

- `userReducer` được import từ module `./user.slice` và là một reducer được tạo ra bằng cách sử dụng Redux Toolkit `createSlice`. Reducer này quản lý trạng thái của người dùng trong Redux store.

```jsx
export const store = configureStore({
  reducer: {
    users: userReducer,
    [userApi.reducerPath]: userApi.reducer,
  },
  middleware: (getDefaultMiddleware) =>
    getDefaultMiddleware().concat(userApi.middleware),
});
```

- Đoạn code trên có mục đích cấu hình Redux store sử dụng Redux Toolkit và tích hợp RTK Query vào trong ứng dụng.

- `store` là một biến lưu trữ Redux store được tạo ra bằng cách sử dụng hàm `configureStore` của Redux Toolkit.

- Trong đối tượng cấu hình của `configureStore`, chúng ta định nghĩa thuộc tính `reducer` và `middleware`.

  - Thuộc tính `reducer` là một đối tượng mô tả các reducer trong ứng dụng. Trong trường hợp này, chúng ta có một reducer là `userReducer` quản lý trạng thái người dùng. Đồng thời, chúng ta sử dụng `userApi.reducer` để quản lý trạng thái liên quan đến RTK Query.
  - Thuộc tính `[userApi.reducerPath]` là một cú pháp đặc biệt để xác định tên của reducer liên quan đến RTK Query. Điều này cho phép RTK Query quản lý trạng thái của các endpoints được định nghĩa trong `userApi`.

- Thuộc tính `middleware` là một hàm nhận vào `getDefaultMiddleware` và trả về một mảng các middleware. Trong trường hợp này, chúng ta sử dụng `getDefaultMiddleware` để lấy danh sách các middleware mặc định của Redux Toolkit. Sau đó, chúng ta kết hợp các middleware mặc định với `userApi.middleware` để tích hợp middleware của RTK Query vào Redux store.

- Kết quả là `store` được tạo ra sẽ có cấu hình sẵn với reducer quản lý trạng thái người dùng và trạng thái liên quan đến RTK Query, cùng với `middleware` để xử lý các `action` và gửi các yêu cầu liên quan đến RTK Query.

```jsx
export default store;
```

- Dòng code `export default store;` được sử dụng để xuất giá trị của biến store ra khỏi module hiện tại để có thể sử dụng trong các module khác.

- Khi một module được xuất dưới dạng `default`, nghĩa là nó là giá trị mặc định của module đó. Trong trường hợp này, `store` là giá trị mặc định của module và nó được xuất ra để có thể được import và sử dụng trong các module khác của ứng dụng.

✅✅✅✅ Đoạn code 4: ✅✅✅✅

- Cuối cùng, trong component React, chúng ta có thể sử dụng hook useGetUsersQuery để truy vấn dữ liệu từ API và hiển thị danh sách người dùng:

```jsx
// UserList.js

import React from "react";
import { useGetUsersQuery } from "./api";

const UserList = () => {
  const { data, error, isLoading } = useGetUsersQuery();

  if (isLoading) {
    return <div>Loading...</div>;
  }

  if (error) {
    return <div>Error: {error.message}</div>;
  }

  return (
    <ul>
      {data.map((user) => (
        <li key={user.id}>{user.name}</li>
      ))}
    </ul>
  );
};

export default UserList;
```

✅✅✅✅❌❌ Dưới đây là phân tích và giải thích từng đoạn code trên ❌❌✅✅✅✅

- Đoạn code trên là một React functional component được gọi là `UserList`. Nó sử dụng hook `useGetUsersQuery` từ module `./api` để truy vấn danh sách người dùng.

- Cách useGetUsersQuery hoạt động trong code: khi `useGetUsersQuery` được gọi, nó trả về một `object` có các thuộc tính như `data`, `error`, và `isLoading` để quản lý trạng thái truy vấn. Trong trường hợp này:

  - `data` chứa dữ liệu trả về từ truy vấn, đây là một mảng các đối tượng người dùng.
  - `error` chứa thông tin lỗi nếu truy vấn không thành công.
  - `isLoading` chỉ định xem truy vấn đang trong quá trình tải hay không.

- Dựa trên các giá trị trên, component `UserList` render ra một danh sách người dùng. Nếu `isLoading` là `true`, component hiển thị thông báo "Loading...". Nếu có lỗi xảy ra, component hiển thị thông báo lỗi với nội dung từ `error.message`. Khi dữ liệu đã tải thành công, component hiển thị danh sách người dùng bằng cách lặp qua mảng `data` và hiển thị tên của mỗi người dùng.

- Cuối cùng, component `UserList` được export mặc định để có thể sử dụng trong các module khác của ứng dụng.

- 👉 Tổng quan lại: với ví dụ trên, chúng ta đã sử dụng RTK Query để truy vấn danh sách người dùng từ API và hiển thị kết quả trong một component React. RTK Query sẽ tự động quản lý `caching` và `refetching` dữ liệu, giúp tối ưu hiệu suất và tiết kiệm công sức trong việc truy vấn dữ liệu từ API.

## RTK Query sử dụng trong trường hợp nào ?

- `RTK Query` được sử dụng trong các trường hợp sau:

- Truy vấn dữ liệu từ API: `RTK Query` cung cấp một cách tiện lợi để truy vấn dữ liệu từ API. Bạn có thể định nghĩa các endpoint và `RTK Query` sẽ tự động tạo ra các hàm truy vấn và các trạng thái liên quan để quản lý dữ liệu và xử lý các trạng thái truy vấn.

- Caching dữ liệu: `RTK Query` hỗ trợ tính năng caching dữ liệu tự động. Khi bạn truy vấn dữ liệu từ API, `RTK Query` sẽ tự động lưu trữ kết quả truy vấn và kiểm tra các phiên bản cache để trả về dữ liệu lưu trữ thay vì gửi yêu cầu truy vấn mới đến API. Điều này giúp tăng tốc độ và giảm tải cho ứng dụng của bạn.

- Tự động invalidation: `RTK Query` cung cấp cơ chế tự động invalidation khi dữ liệu hết hạn hoặc không còn đúng. Khi bạn thực hiện các thao tác sửa đổi dữ liệu (thêm (`POST`), cập nhật (`PUT`), xóa (`DELETE`)) thông qua `RTK Query`, nó sẽ tự động xóa dữ liệu cache tương ứng để đảm bảo dữ liệu mới nhất được truy vấn từ API. Nói một cách dễ hiểu nó có nghĩa là: Tự động gọi API lại khi có các thay đổi liên quan đến dữ liệu. Nó là một hàm có tên là `invalidatesTags`

- Quản lý trạng thái truy vấn: `RTK Query` quản lý trạng thái truy vấn tự động. Bạn có thể dễ dàng kiểm tra trạng thái truy vấn như đang loading, đã hoàn thành, hoặc có lỗi để điều chỉnh hiển thị và xử lý trong giao diện người dùng.

- Tích hợp với Redux Toolkit: `RTK Query` được thiết kế để tích hợp sẵn với Redux Toolkit, giúp đơn giản hóa việc quản lý state và sử dụng các công cụ và tính năng của Redux Toolkit.

=> Tóm lại: `RTK Query` giúp cho việc xây dựng ứng dụng React có tương tác với API dễ dàng, hiệu quả và hạn chế được nhiều công việc lặp lại trong quá trình quản lý trạng thái và truy vấn dữ liệu.

✅✅✅✅ Dưới đây là docs của Được Dev ✅✅✅✅

# RTK query

## RTK query là gì?

RTK query là thư viện thuộc hệ sinh thái Redux giúp chúng ta quản lý việc gọi API và caching dễ dàng.

### Lý do RTK query xuất hiện

Giúp chúng ta hạn chế những việc lặp đi lặp lại trong quá trình fetch data.

Để fetch data trong React

- Khai báo useEffect và gọi API trong đó
- Xử lý cleanup function để tránh việc gọi duplicate data
- Tracking trạng thái loading để hiển thị skeleton
- Quản lý thời gian cache khi user tương tác với UI

Những việc này không khó, nhưng nó nhiều, nếu nhiều component cần implement cái này thì khá mệt. Nếu dùng với Redux thì mệt hơn nữa khi mỗi lần gọi API phải khai báo action, thunk các kiểu. Ngay cả khi khi chúng ta sử dụng `createAsyncThunk` cùng với `createSlice` thì vẫn còn những hạn chế khi chúng ta phải tự quản lý state loading hay tránh gọi duplicate request.

Những năm gần đây, cộng đồng React nhận ra rằng **fetch data và caching cũng là một nỗi lo khác cùng với việc quản lý state**.

RTK Query lấy cảm hứng từ những thư viện như Apollo Client, React Query, Urql và SWR nhưng được build trên Redux Toolkit
