## Hãy định nghĩa chi tiết và rõ ràng nhất về `createSlice` ?

- `createSlice` là một phương thức được cung cấp bởi `Redux Toolkit`, giúp đơn giản hóa việc tạo ra các `slice`, `reducer` và `action creators` trong Redux.

- Mỗi `slice` đại diện cho một phần của `state` của ứng dụng, bao gồm một `reducer` và các `action creators` tương ứng để thay đổi `state`. Với `createSlice`, bạn chỉ cần định nghĩa các `reducer function`, và các `action types` và `action creators` tương ứng sẽ được tự động tạo ra.

- Phương thức `createSlice` có các đối số như sau:

  - `name`: Tên của slice.
  - `initialState`: Giá trị khởi tạo cho slice.
  - `reducers`: Một đối tượng chứa các reducer function, trong đó mỗi `key` là tên của reducer function, và giá trị (`value`) là reducer function tương ứng.

- Khi bạn sử dụng `createSlice`, phương thức sẽ trả về một đối tượng với hai thuộc tính là `actions` và `reducer`, tương ứng với các `action creators` và `reducer` của `slice` được tạo ra. Các `action creators` đã được tạo ra sẽ có tên giống với tên của `reducer function` và sẽ trả về một `action object` có chứa action `type` và `payload`.

- Sử dụng `createSlice` giúp giảm thiểu đáng kể khối lượng mã cần phải viết và giúp cho việc quản lý `state` của ứng dụng trở nên dễ dàng hơn. Ngoài ra, phương thức này còn cung cấp các tiện ích để xử lý các `action` có chứa `side effects`, sử dụng `createAsyncThunk`.

## Mình phải tạo `slice` và `reducer` trước rồi mới tạo file `store` đúng không. Ý của tôi nói là `các bước` để tạo `store` theo thứ tự ?

- Đúng, để tạo một Redux store trong Redux Toolkit, bạn cần thực hiện các bước sau theo thứ tự:

1. `Tạo slice và reducer`: Đầu tiên, bạn cần tạo các `slice` và `reducer` để quản lý `state` và xử lý các `action` tương ứng. Điều này thường được thực hiện bằng cách sử dụng hàm `createSlice` trong Redux Toolkit. Trong slice, bạn định nghĩa các thuộc tính như `name`, `initialState` và `reducers`.

2. `Kết hợp reducer`: Sau khi tạo các reducer từ slice, bạn cần kết hợp chúng lại để tạo ra một reducer duy nhất. Điều này có thể được thực hiện bằng cách sử dụng hàm `combineReducers` từ Redux Toolkit hoặc bất kỳ cách nào khác để kết hợp các reducer lại với nhau.

3. `Tạo store`: Tiếp theo, bạn cần tạo một Redux store bằng cách sử dụng hàm `configureStore` từ Redux Toolkit. Trong hàm này, bạn truyền vào đối số là `reducer` đã được kết hợp.

4. `Sử dụng store`: Cuối cùng, bạn có thể sử dụng `store` trong ứng dụng của mình. Cách sử dụng `store` phụ thuộc vào framework hoặc thư viện bạn đang sử dụng, như `React`, `Angular`, `Vue`, hoặc `vanilla JavaScript`.

- Ví dụ:

```jsx
import { createSlice, configureStore } from "@reduxjs/toolkit";

// Tạo slice và reducer
const counterSlice = createSlice({
  name: "counter",
  initialState: 0,
  reducers: {
    increment: (state) => state + 1,
    decrement: (state) => state - 1,
  },
});

// Kết hợp reducer
const rootReducer = combineReducers({
  counter: counterSlice.reducer,
  // Các reducer khác...
});

// Tạo store
const store = configureStore({
  reducer: rootReducer,
});

// Sử dụng store trong ứng dụng
// Ví dụ: Sử dụng store trong React với react-redux
import { Provider } from "react-redux";

ReactDOM.render(
  <Provider store={store}>
    <App />
  </Provider>,
  document.getElementById("root")
);
```

- Lưu ý rằng các bước trên đây chỉ là một quy trình tổng quan để tạo một Redux store trong Redux Toolkit. Tùy thuộc vào nhu cầu và yêu cầu cụ thể của dự án của bạn, bạn có thể tùy chỉnh và mở rộng các bước này.

## ✅✅✅✅ 4. `Sử dụng store`: Cuối cùng, bạn có thể sử dụng `store` trong ứng dụng của mình. Cách sử dụng `store` phụ thuộc vào framework hoặc thư viện bạn đang sử dụng, như `React`, `Angular`, `Vue`, hoặc `vanilla JavaScript`. Hãy nói chi tiết về bước này. Tôi đang sử dụng react ? ✅✅✅✅

- Khi bạn sử dụng React và Redux Toolkit, bạn có thể sử dụng `react-redux` để kết nối `store` với ứng dụng React của bạn. Dưới đây là các bước chi tiết để sử dụng `store` trong React:

1. Cài đặt các package cần thiết:

```jsx
npm install react-redux
```

2. Tạo một file `store.js` để khởi tạo và xuất `store`:

```jsx
import { configureStore } from "@reduxjs/toolkit";
import rootReducer from "./reducers";

const store = configureStore({
  reducer: rootReducer,
});

export default store;
```

3. Trong component gốc của ứng dụng React (thường là `index.js` hoặc `App.js`), sử dụng `<Provider>` để cung cấp `store` cho ứng dụng:

```jsx
import React from "react";
import ReactDOM from "react-dom";
import { Provider } from "react-redux";
import store from "./store";
import App from "./App";

ReactDOM.render(
  <Provider store={store}>
    <App />
  </Provider>,
  document.getElementById("root")
);
```

4. Trong các component con của ứng dụng React, bạn có thể sử dụng hooks như `useDispatch` và `useSelector` để tương tác với `store`:

- Sử dụng `useDispatch` để dispatch action:

```jsx
import { useDispatch } from "react-redux";
import { increment } from "./reducers/counter";

const MyComponent = () => {
  const dispatch = useDispatch();

  const handleIncrement = (count) => {
    dispatch(increment(count)); // Giải sử increment là action và count là payload
  };

  return <button onClick={handleIncrement}>Increment</button>;
};
```

- Sử dụng `useSelector` để lấy state từ store:

```jsx
import { useSelector } from "react-redux";
import { selectCount } from "./reducers/counter";

const CounterDisplay = () => {
  const count = useSelector(selectCount);

  return <p>Count: {count}</p>;
};
```

- Điều này cho phép bạn sử dụng `store` và tương tác với `state` và `actions` của nó trong các component React của bạn. Bất kỳ thay đổi nào trong `store` cũng sẽ tự động kích hoạt việc cập nhật giao diện React tương ứng.

## Thế nào là 1 `slice` trong `createSlice` ?

- Trong Redux, "`slice`" đề cập đến một phần của store Redux chứa `state`, `reducers` và `actions` liên quan đến một phần cụ thể của ứng dụng. Mỗi `slice` đại diện cho một phần riêng biệt của state và cung cấp các phương thức để thay đổi state đó.

- Slice thường được tạo bằng cách sử dụng `createSlice` từ Redux Toolkit hoặc viết các `reducers`, `actions` và `selectors` thủ công. Một `slice` bao gồm các thành phần sau:

1. `State`: Đây là nơi lưu trữ thông tin cần thiết cho phần của ứng dụng được đại diện bởi slice. State thường được khởi tạo ban đầu và có thể thay đổi khi các actions được gửi đến reducers của slice.

2. `Reducers`: Các reducers định nghĩa cách state của slice sẽ thay đổi khi nhận các actions tương ứng. Mỗi reducer nhận vào state hiện tại và một action, sau đó trả về một state mới sau khi thực hiện các thay đổi cần thiết.

3. `Actions`: Actions là các đối tượng chứa thông tin về các sự kiện xảy ra trong ứng dụng. Mỗi action có một `type` để xác định loại action và các thông tin bổ sung khác có thể được chứa trong các thuộc tính khác của action.

4. `Selectors`: Selectors cho phép bạn truy cập và chọn lọc các phần của state từ store Redux. Bằng cách sử dụng selectors, bạn có thể lấy các giá trị cần thiết từ slice để sử dụng trong các component hoặc các phần khác của ứng dụng.

- Slice giúp tách nhỏ store Redux thành các phần nhỏ hơn, dễ quản lý và tái sử dụng. Mỗi slice có thể chứa state và các logic riêng biệt cho một phần cụ thể của ứng dụng, đồng thời nó cũng giúp tăng tính module hóa và khả năng mở rộng của ứng dụng Redux.

- Trong Redux Toolkit, một slice không chỉ chứa state mà còn chứa reducer và action creators tương ứng.

- Khi sử dụng `createSlice` trong Redux Toolkit, bạn cung cấp một đối tượng có các thuộc tính `name`, `initialState`, `reducers` và tùy chọn `extraReducers`. Hàm `createSlice` sẽ tự động tạo reducer và các `action creators` dựa trên các thông tin bạn cung cấp.

  - `Reducer`: Reducer của slice sẽ xử lý các action tương ứng với slice đó. Mỗi reducer trong slice sẽ nhận vào state hiện tại của slice và action tương ứng, và trả về state mới sau khi xử lý action đó. Redux Toolkit sẽ tự động tạo reducer dựa trên `reducers` bạn định nghĩa trong slice.

  - `Action Creators`: Action creators của slice là các hàm JavaScript thông thường được tạo tự động bởi Redux Toolkit. Chúng là các hàm giúp tạo ra các action tương ứng với slice đó, với các thuộc tính như `type` (loại action) và `payload` (dữ liệu đi kèm). Action creators giúp bạn dễ dàng dispatch action mà không cần phải viết thủ công các đối tượng action.

- Ví dụ:

```jsx
import { createSlice } from "@reduxjs/toolkit";
const counterSlice = createSlice({
  name: "counter",
  initialState: 0,
  reducers: {
    increment: (state) => {
      return state + 1;
    },
    decrement: (state) => {
      return state - 1;
    },
  },
});

export const { increment, decrement } = counterSlice.actions;
export default counterSlice.reducer;
```

- Trong ví dụ trên, slice có tên là '`counter`' và state ban đầu là `0`. Redux Toolkit tự động tạo reducer và action creators dựa trên `reducers` bạn định nghĩa trong slice. Bạn có thể sử dụng action creators như `increment()` và `decrement()` để dispatch các action tương ứng và reducer sẽ xử lý những action đó để cập nhật state của slice.

## Làm sao để tạo một `slice` mới trong Redux Toolkit ?

- Để tạo một slice mới trong Redux Toolkit, bạn có thể sử dụng hàm `createSlice` từ thư viện `@reduxjs/toolkit`. Dưới đây là các bước để tạo một slice mới:

1. Import `createSlice` từ `@reduxjs/toolkit`:

```jsx
import { createSlice } from "@reduxjs/toolkit";
```

2. Sử dụng hàm `createSlice` để tạo slice mới. Hàm này nhận vào một đối tượng cấu hình (configuration object) chứa thông tin về slice.

```jsx
const mySlice = createSlice({
  name: "mySlice", // Tên của slice
  initialState: initialStateValue, // Giá trị ban đầu của state
  reducers: {
    // Các reducers để xử lý các action
    reducer1: (state, action) => {
      // Xử lý action và cập nhật state
    },
    reducer2: (state, action) => {
      // Xử lý action và cập nhật state
    },
    // ...
  },
});
```

3. Export các action creators và reducer từ slice:

```jsx
export const { reducer1, reducer2 } = mySlice.actions;
export default mySlice.reducer;
```

- Sau khi tạo slice, bạn có thể sử dụng reducer và action creators được tạo tự động bởi Redux Toolkit để thao tác với state trong Redux.

- Ví dụ:

```jsx
import { createSlice } from "@reduxjs/toolkit";

const counterSlice = createSlice({
  name: "counter",
  initialState: 0,
  reducers: {
    increment: (state) => {
      state += 1;
    },
    decrement: (state) => {
      state -= 1;
    },
  },
});

export const { increment, decrement } = counterSlice.actions;
export default counterSlice.reducer;
```

- Trên đây là cách tạo một slice mới trong Redux Toolkit bằng cách sử dụng hàm `createSlice`.

- 👇 1 `slice` có nghĩa là mỗi cái `object` trong reducers phải không 👇?

```jsx
const mySlice = createSlice({
  reducers: {
    // Các reducers để xử lý các action
    reducer1: (state, action) => {
      // Xử lý action và cập nhật state
    },
    reducer2: (state, action) => {
      // Xử lý action và cập nhật state
    },
    // ...
  },
});
```

- Trong Redux Toolkit, một slice không chỉ đại diện cho mỗi object, mà thực tế nó đại diện cho một phần của state và các reducers liên quan đến phần đó.

- Trong ví dụ của bạn, `reducers` là một object chứa các reducers để xử lý các action. Mỗi reducer là một hàm JavaScript nhận vào hai đối số là `state` và `action`, và được sử dụng để cập nhật state dựa trên action tương ứng.

- Ví dụ:

```jsx
const mySlice = createSlice({
  name: "mySlice",
  initialState: { count: 0, name: "" },
  reducers: {
    increment: (state, action) => {
      state.count += action.payload;
    },
    setName: (state, action) => {
      state.name = action.payload;
    },
  },
});
```

- Trong ví dụ trên, slice "mySlice" bao gồm hai reducers là "increment" và "setName". Mỗi reducer được sử dụng để cập nhật một phần của state. Ví dụ, reducer "increment" tăng giá trị của `count` trong state của slice, và reducer "setName" đặt giá trị của `name` trong state.

- Từ đó, một slice trong Redux Toolkit không chỉ đại diện cho mỗi object mà chứa các reducers, mà thực tế nó đại diện cho một phần của state và các reducers liên quan để cập nhật phần đó của state.

✅✅✅✅ Như vậy kết luận ✅✅✅✅

- Như vậy thì 1 `slice` là 1 phần chứa trong `createSlice` đúng không ?

```jsx
const mySlice = createSlice({
  name: "mySlice",
  initialState: { count: 0, name: "" },
  reducers: {
    increment: (state, action) => {
      state.count += action.payload;
    },
    setName: (state, action) => {
      state.name = action.payload;
    },
  },
});
```

- Đúng, trong Redux Toolkit, một slice là một phần tử chứa trong hàm `createSlice`. Mỗi slice được định nghĩa bởi một object có các thuộc tính như `name`, `initialState` và `reducers`.

- Trong ví dụ của bạn, object `{ name: 'mySlice', initialState: { count: 0, name: '' }, reducers: { ... } }` đại diện cho một slice có tên là "mySlice". Nó bao gồm một initialState ban đầu là `{ count: 0, name: '' }` và một object reducers chứa các reducers để xử lý các action tương ứng.

- Khi chúng ta sử dụng hàm `createSlice` và truyền vào object định nghĩa slice, Redux Toolkit sẽ tự động tạo ra một reducer duy nhất cho slice đó, cùng với các action creators tương ứng.

- Ví dụ, trong trường hợp của bạn, Redux Toolkit sẽ tự động tạo ra reducer cho slice "`mySlice`" và các action creators là "`increment`" và "`setName`" thông qua 2 câu lệnh.

```jsx
export const { increment, decrement } = counterSlice.actions;
export default counterSlice.reducer;
```

- Tóm lại, một slice trong Redux Toolkit là một phần tử đại diện cho một phần của state và các reducers liên quan để cập nhật phần đó của state. Nó được định nghĩa bằng cách sử dụng hàm `createSlice` và truyền vào một object định nghĩa slice.

✅✅✅✅ Giải thích về đoạn code ở trên ? chú ý đến `action.payload` bởi vì nó được dùng nhiều trong redux ✅✅✅✅

```jsx
state.count += action.payload;
```

- Trong đoạn mã `state.count += action.payload;`, câu lệnh này được sử dụng để cập nhật giá trị của thuộc tính `count` trong đối tượng `state`.

  - `state` là tham chiếu đến đối tượng state hiện tại.
  - `state.count` truy cập thuộc tính `count` trong đối tượng state.
  - `action.payload` là giá trị được truyền vào thông qua thuộc tính `payload` của action.
  - Toán tử `+=` được sử dụng để thêm giá trị của `action.payload` vào giá trị hiện tại của `state.count`. Nó tương đương với việc `state.count = state.count + action.payload`.

- Ví dụ: Nếu `state.count` ban đầu là 5 và `action.payload` là 3, sau khi thực hiện câu lệnh `state.count += action.payload;`, giá trị của `state.count` sẽ được cập nhật thành 8.

- Lưu ý rằng trong `Redux Toolkit`, việc cập nhật trực tiếp trên `state` được hỗ trợ bởi thư viện `Immer` để đảm bảo tính bất biến (`immutable`) của state. Thay vì thay đổi trực tiếp giá trị, `Immer` sẽ tạo ra một bản sao không thay đổi của state và áp dụng các thay đổi lên bản sao đó, từ đó trả về một `state` mới đã được cập nhật.

✅✅✅✅ Nói 1 cách bao quát `action.payload` là để lấy dữ liệu hả ? ✅✅✅✅

- Đúng, `action.payload` trong Redux Toolkit được sử dụng để lấy dữ liệu từ `action` gửi vào `reducer`. Khi `dispatch` một `action`, ta có thể gửi thông tin hoặc dữ liệu bổ sung cần thiết để thay đổi `state`. Điều này giúp `reducer` biết được những thông tin cần thiết để thực hiện các `logic` xử lý và cập nhật `state` phù hợp.

- Về ví dụ của bạn, trong reducer `addTodo` của ví dụ dưới cảu bạn 👇, `action.payload` có thể là một đối tượng chứa thông tin về todo mới cần được thêm vào `state`. Trong reducer `toggleTodo`, `action.payload` có thể chứa một thuộc tính `id` để xác định todo cần thay đổi trạng thái.

- `action.payload` là một thuộc tính linh hoạt và có thể mang theo bất kỳ dữ liệu nào cần thiết cho `reducer`. Cách sử dụng và nội dung của `action.payload` phụ thuộc vào cách bạn định nghĩa và gửi các `action` trong ứng dụng của bạn.

## hướng dẫn sử dụng thư viện `Immerjs` để giúp xử lý `state` trong redux toolkit ?

- `Immer` không phải là một thư viện có sẵn của Redux, mà là một thư viện JavaScript độc lập được sử dụng để làm việc với state không thay đổi (immutable state) một cách dễ dàng.

- `Immer` cung cấp một cách tiếp cận dễ hiểu và thuận tiện để tạo và cập nhật `state immutable`. Thay vì bạn phải tạo ra các bản sao của state và sử dụng các phép toán không thay đổi (immutability operators) để tạo ra state mới, `Immer` cho phép bạn thay đổi state trực tiếp một cách tường minh, nhưng nó sẽ tự động xử lý việc tạo bản sao và áp dụng các thay đổi một cách an toàn.

- Một trong những cách phổ biến nhất để sử dụng `Immer` trong Redux là thông qua `Redux Toolkit`. Redux Toolkit tích hợp `Immer` sẵn có và sử dụng `Immer` để xử lý state trong reducers một cách tiện lợi.

- Khi bạn sử dụng `Redux Toolkit` và tạo `reducers` bằng cách sử dụng `createSlice`, Redux Toolkit sẽ tự động sử dụng `Immer` để xử lý `state`. Bạn không cần phải lo lắng về việc tạo bản sao của state và cung cấp reducers dựa trên `Immer`.

- Ví dụ:

```jsx
import { createSlice } from "@reduxjs/toolkit";

const counterSlice = createSlice({
  name: "counter",
  initialState: 0,
  reducers: {
    increment: (state) => {
      state += 1; // Sử dụng Immer để thay đổi state trực tiếp
    },
    decrement: (state) => {
      state -= 1;
    },
  },
});

export const { increment, decrement } = counterSlice.actions;
export default counterSlice.reducer;
```

- Trong ví dụ trên, Redux Toolkit sử dụng `Immer` để tự động xử lý việc tạo bản sao và áp dụng các thay đổi vào state khi bạn thay đổi trực tiếp `state` bên trong reducers.

## Cho ví dụ khác về việc sử dụng `immer` trong redux toolkit ?

- Trong ví dụ này chúng ta sử dụng cú pháp gán (assignment syntax) để tạo một bản sao mới của state và thực hiện các thay đổi trên bản sao đó. Dưới đây là ví dụ sử dụng cú pháp gán trong Redux Toolkit:

```jsx
import { createSlice } from "@reduxjs/toolkit";

// Tạo slice
const todosSlice = createSlice({
  name: "todos",
  initialState: [],
  reducers: {
    addTodo: (state, action) => {
      // Thêm một todo vào state
      state.push(action.payload);
    },
    toggleTodo: (state, action) => {
      const { id } = action.payload;
      // Thay đổi trạng thái của một todo trong state
      const todo = state.find((todo) => todo.id === id);
      if (todo) {
        todo.completed = !todo.completed;
      }
    },
    // Các reducers khác...
  },
});

// Export action creators
export const { addTodo, toggleTodo } = todosSlice.actions;

// Export reducer
export default todosSlice.reducer;
```

- ✅✅✅✅ Giải thích code: ✅✅✅✅

- ví dụ trên sử dụng phương pháp `state mutable`, tức là `state` được thay đổi trực tiếp mà không tạo bản sao. Điều này có thể nhìn thấy trong việc sử dụng các phương thức `mutable` như `push` và gán trực tiếp các thuộc tính của các đối tượng trong `state`. Dưới đây là cách phương pháp này hoạt động:

1. Khởi tạo slice sử dụng `createSlice` từ Redux Toolkit. `Slice` là một cách tổ chức `state` và các `reducers` tương ứng của nó. Trong ví dụ, `slice` có tên là "`todos`".

2. Định nghĩa `initialState` ban đầu của `slice` là một mảng rỗng `[]`.

3. Định nghĩa các `reducers` bằng cách sử dụng cú pháp rút gọn của Redux Toolkit. Ví dụ:

- `addTodo`: Nhận `state` và `action` làm tham số. Trong reducers này, chúng ta thêm một todo mới vào mảng `state` bằng cách sử dụng `push`. Phương pháp này thay đổi trực tiếp mảng state.

- `toggleTodo`: Nhận `state` và `action` làm tham số. Trong reducers này, chúng ta tìm todo có `id` tương ứng trong mảng `state` và thay đổi trạng thái hoàn thành (`completed`) của nó bằng cách đảo ngược giá trị hiện tại. Lưu ý là chúng ta không thay đổi mảng `state` mà chỉ thay đổi các thuộc tính bên trong các đối tượng todo.

4. Export các action creators tương ứng (`addTodo`, `toggleTodo`) được tạo ra bởi Redux Toolkit từ slice. Các action creators này có thể được sử dụng để dispatch các action tương ứng trong ứng dụng React.

5. Export reducer của slice (`todosSlice.reducer`). Reducer này sẽ được sử dụng để quản lý state của slice trong Redux store.

- Phương pháp này sử dụng cơ chế tạo ra state mới bằng cách tạo ra một bản sao (copy) của state hiện tại và thực hiện các thay đổi trên bản sao đó. Điều này giúp đảm bảo tính không thay đổi của state ban đầu và khắc phục vấn đề liên quan đến mutable state trong Redux.

- Trong ví dụ này, chúng ta thực hiện các thay đổi trực tiếp trên `state` bằng cách sử dụng cú pháp gán (`=`) để tạo bản sao mới của `state` và thực hiện các thay đổi trên bản sao đó. Lưu ý rằng điều này đòi hỏi `state` trong Redux Toolkit phải là `mutable` (có thể thay đổi trực tiếp).

- Trong ví dụ trên, không sử dụng phương pháp `state immutable` mà sử dụng phương pháp `state mutable`.

- Khi thay đổi `state`, chúng ta thực hiện các thay đổi trực tiếp trên `state` hiện tại bằng cách sử dụng cú pháp gán (`=`) để thay đổi giá trị của thuộc tính trong `state`.

- Phương pháp `state mutable` có ý nghĩa là chúng ta thay đổi trực tiếp giá trị của `state` hiện tại mà không tạo ra một bản sao mới của `state`. Điều này có thể dẫn đến các vấn đề như làm thay đổi `state gốc` mà không thể theo dõi được lịch sử thay đổi, gây khó khăn trong việc quản lý và gỡ lỗi.

- Ngược lại, phương pháp `state immutable` yêu cầu chúng ta tạo ra một bản sao mới của state mỗi khi thay đổi state. Thay đổi giá trị trong bản sao mới này đảm bảo rằng `state gốc` không bị thay đổi, và ta có thể theo dõi và quản lý lịch sử thay đổi của state một cách dễ dàng. Redux Toolkit sử dụng thư viện Immer để hỗ trợ việc làm việc với `state immutable` một cách thuận tiện và tự động.

## Hãy giải thích câu này: `Redux Toolkit` sử dụng thư viện `Immer` để hỗ trợ việc làm việc với `state immutable` một cách thuận tiện và tự động:

- Khi làm việc với state immutable, nghĩa là state không thay đổi trực tiếp, ta thường phải tạo bản sao của state và thực hiện các thay đổi trên bản sao đó. Điều này đảm bảo rằng state gốc không bị thay đổi và ta có thể theo dõi lịch sử các thay đổi.

- Tuy nhiên, việc tạo bản sao và thực hiện các thay đổi trên bản sao có thể tốn nhiều công sức và dễ gây nhầm lẫn. Đó là khi Immer đến cứu giúp. Immer giúp ta làm việc với state immutable một cách dễ dàng hơn bằng cách cho phép ta thay đổi state trực tiếp mà không cần phải tạo bản sao.

- Khi ta sử dụng Immer, ta có thể thay đổi state trực tiếp, nhưng Immer sẽ tự động tạo ra một bản sao ẩn của state và áp dụng các thay đổi lên bản sao đó. Điều này đảm bảo rằng state gốc không bị thay đổi và ta vẫn có thể theo dõi lịch sử thay đổi của state.

- Vì vậy, thư viện Immer giúp ta làm việc với state immutable một cách thuận tiện và tự động, mà không cần phải tạo bản sao và làm việc với nó trực tiếp.

=> Tóm lại, khi làm việc với `immutable state`, ta cần tạo bản sao để thực hiện các thay đổi và đảm bảo tính không thay đổi của state gốc. Trong khi đó, khi làm việc với `mutable state`, ta thay đổi trực tiếp giá trị của state mà không cần tạo bản sao.

## Đây là ví dụ nhỏ về `createSlice` trong redux toolkit:

```jsx
import { createSlice } from "@reduxjs/toolkit";

const counterSlice = createSlice({
  name: "counter",
  initialState: 0,
  reducers: {
    increment: (state) => {
      return state + 1;
    },
    decrement: (state) => {
      return state - 1;
    },
    reset: () => {
      return 0;
    },
  },
});

export const { increment, decrement, reset } = counterSlice.actions;
export default counterSlice.reducer;
```

- Trong ví dụ trên, chúng ta tạo một slice có tên là 'counter'. State ban đầu của slice được định nghĩa là 0. Các reducers được định nghĩa trong `reducers` object. Mỗi reducer nhận state hiện tại và trả về một state mới sau khi thực hiện các thay đổi.

- Các action tương ứng với reducers được tạo tự động bởi Redux Toolkit và xuất ra bên ngoài (`export const { increment, decrement, reset } = counterSlice.actions`). Bạn có thể sử dụng các action này để gọi các reducers tương ứng trong store Redux.

- Khi slice được kết hợp vào rootReducer của bạn, state của slice sẽ được quản lý trong store chung và bạn có thể truy cập nó từ các component trong ứng dụng.

## Đây là khái niệm về `createSlice` nhưng có kèm ví dụ cho dễ hình dung:

- `createSlice` là một phương thức của `Redux Toolkit`, cho phép bạn tạo ra một `slice`, bao gồm một `reducer` và các `action creators` tương ứng, chỉ trong một bước. Mỗi `slice` đại diện cho một phần của `state` của ứng dụng và chứa các hành động (`action`) và `reducer` liên quan đến phần đó của `state`.

- Để sử dụng `createSlice`, bạn cần `import` nó từ `@reduxjs/toolkit`.

```jsx
import { createSlice } from "@reduxjs/toolkit";
```

- Sau đó, bạn có thể sử dụng `createSlice` để tạo ra một `slice` của `state` với cú pháp như sau:

```jsx
const sliceName = createSlice({
  name: 'sliceName',
  initialState: initialStateValue,
  reducers: {
    reducerFunction1: (state, action) => { ... },
    reducerFunction2: (state, action) => { ... },
    ...
  }
})
```

- Trong đó có:

  - `name`: là tên của slice.
  - `initialState`: là giá trị khởi tạo cho slice đó.
  - `reducers`: là một đối tượng (`object`) chứa các `reducer functions` và `action creators` tương ứng. Bạn cần đặt tên cho các `reducer functions` và `Redux Toolkit` sẽ tự động tạo ra các `action types` tương ứng.

- Mỗi `reducer function` nhận vào hai đối số: `state` và `action`. `state` đại diện cho `giá trị hiện tại` của `slice`, và `action` đại diện cho `hành động` được gửi đến `reducer`. Trong `reducer function`, bạn cần thay đổi `state` của `slice` dựa trên hành động được gửi đến.

- Sau khi sử dụng `createSlice`, bạn sẽ nhận được một đối tượng (`object`) có hai thuộc tính là `actions` và `reducer`, tương ứng với các `action creators` và `reducer` của `slice` đó.

```jsx
console.log(sliceName.actions);
console.log(sliceName.reducer);
```

- Bạn có thể sử dụng các `action creators` đã được tạo ra để gửi các hành động (`action`) đến `reducer`, và sử dụng `reducer` để thay đổi `state` của `slice`.

- Với `createSlice`, việc tạo `reducer` và các `action creators` trở nên dễ dàng và tự động hơn, giúp giảm thiểu khối lượng mã cần phải viết và giúp cho việc quản lý `state` của ứng dụng trở nên dễ dàng hơn.

**cho phép bạn tạo ra một `slice`, bao gồm một `reducer` và các `action creators` tương ứng...**

- Tôi chưa hiểu dòng đó. Hãy giải thích chi tiết hơn:

  - Trong `Redux`, một `slice` đại diện cho một phần của `state` của ứng dụng và bao gồm một `reducer function` và các `action creators` tương ứng để thay đổi `state` đó.

  - `createSlice` sẽ tự động tạo ra các `action creators` tương ứng cho mỗi `reducer function` được định nghĩa trong `reducers`. Các `action creators` này sẽ có tên `giống` với tên của `reducer function` và trả về một `action object` chứa thông tin về `action type` và `payload`. Bằng cách sử dụng các `action creators` này, bạn có thể gửi các `action` tới `reducer` để thay đổi `state` của ứng dụng.

  - `createSlice` là một phương thức của `Redux Toolkit` giúp tạo ra một `slice` đơn giản hơn. Bằng cách sử dụng `createSlice`, bạn có thể định nghĩa một đối tượng `reducers` gồm các `reducer function`. Mỗi `reducer function` đại diện cho một phần của `state` và xử lý các `action` liên quan đến phần đó của `state`.

  - Cuối cùng, `createSlice` trả về một đối tượng `slice` chứa `reducer function` và các `action creators` tương ứng, giúp cho việc quản lý `state` của ứng dụng trở nên dễ dàng hơn.

## `reducer function` và các `action creators` là gì ?

- Trong `Redux`, một `reducer function` là một hàm xử lý các `action` và thay đổi `state` của ứng dụng. `Reducer function` nhận vào hai đối số là `state hiện tại` và một `action`, và trả về `state mới` của ứng dụng.

- Các `action creators` là các hàm đơn giản trả về một `action object`, chứa thông tin về `action type` và `payload`. `Action object` này được gửi tới `reducer` để thay đổi `state` của ứng dụng. Việc sử dụng `action creators` giúp cho việc quản lý `action types` của ứng dụng trở nên dễ dàng hơn và giúp tránh việc lỗi chính tả trong việc gửi `action` tới `reducer`.

- Khi sử dụng `Redux Toolkit`, việc tạo `reducer function` và các `action creators` trở nên đơn giản hơn nhờ các phương thức như `createSlice` và `createAction`. Các phương thức này giúp tự động tạo ra các `action types` và `action creators` tương ứng, giúp cho việc xử lý `state` của ứng dụng trở nên dễ dàng hơn.

## Trong `action creators` là nó chứa gì ?

- `Action creators` là các hàm trả về một `action object`, chứa thông tin về `action type` và `payload`.

- Trong Redux, một `action object` bao gồm hai thuộc tính chính là `type` và `payload`. Thuộc tính `type` xác định loại của `action`, thường được định nghĩa bằng một `string`, và là một trong các `action types` được định nghĩa trong ứng dụng. Thuộc tính `payload` chứa dữ liệu cần thiết để xử lý `action`, và có thể là bất kỳ kiểu dữ liệu nào tùy thuộc vào từng trường hợp cụ thể.

- Ví dụ, nếu bạn muốn định nghĩa một `action creator` cho việc thêm một `todo item` vào danh sách `todos`, bạn có thể sử dụng `createAction` để tạo ra `action creator` và `action object` tương ứng:

```jsx
import { createAction } from "@reduxjs/toolkit";

export const addTodo = createAction("todos/add", (title) => {
  return {
    payload: {
      id: Date.now(),
      title,
      completed: false,
    },
  };
});
```

- Trong đoạn mã trên, `createAction` được sử dụng để tạo ra một `action creator` cho việc thêm một `todo item` vào danh sách `todos`. `Action type` của action này là `'todos/add'`. `Action creator` trả về một `action object` với thuộc tính type là `'todos/add'` và thuộc tính `payload` chứa dữ liệu của `todo item` cần thêm vào danh sách.

## Đoạn code này được lấy từ `file` blog.slice.ts trong `folder` local-blog:

```jsx
const blogSlice = createSlice({
  name: "blog",
  initialState,
  reducers: {
    deletePost: (state, action: PayloadAction<string>) => {
      const postId = action.payload;
      const foundPostIndex = state.postList.findIndex(
        (post) => post.id === postId
      );
      if (foundPostIndex !== -1) {
        state.postList.splice(foundPostIndex, 1);
      }
    },
  },
});
```

- **Trong đoạn code này. Hãy chỉ ra đâu là `name`, `initialState`, `reducers`, `reducer functions`, `action creators` ?**

- Trong đoạn code trên:

  - `name` là chuỗi định danh cho `slice`, có thể được sử dụng để phân biệt slice này với các slice khác.

  - `initialState` là trạng thái ban đầu của slice, được sử dụng để khởi tạo `store`.

  - `reducers` là một đối tượng chứa các `reducer function` được tạo ra bởi `slice`. Mỗi thuộc tính của đối tượng này là một reducer function được định nghĩa để xử lý một `action` cụ thể.

  - `deletePost` là một `reducer function`, được định nghĩa để xử lý `action` có `type` là `'blog/deletePost'`. Reducer function này nhận vào hai đối số là `state` và `action`, và trả về state mới của slice sau khi thực hiện xử lý `action`.

  - `PayloadAction` là một kiểu đối tượng được xác định bởi `Redux Toolkit`, và được sử dụng để định nghĩa kiểu dữ liệu của `payload` trong các `action` tương ứng với `reducer function`. Trong trường hợp này, `deletePost` reducer function sử dụng `PayloadAction<string>` để chỉ ra rằng `payload` của `action` có kiểu là `string`.

- Lưu ý rằng, `createSlice` tự động tạo ra các `action creators` tương ứng cho mỗi `reducer function` được định nghĩa trong `reducers`, vì vậy chúng ta không cần phải tạo các `action creators` thủ công như trong `Redux` truyền thống.

## Đoạn code này được lấy từ `file` blog.slice.ts trong `folder` local-blog:

```jsx
export const {
  addPost,
  cancelEditingPost,
  deletePost,
  finishEditingPost,
  startEditingPost,
} = blogSlice.actions;
```

- Vì sao phải khai báo dòng code này ?

  - Khi chúng ta sử dụng `createSlice()` để tạo một `slice`, nó sẽ trả về một đối tượng có chứa các `action creators` tương ứng với các `reducer functions` đã khai báo. Các `action creator` này được tạo ra tự động dựa trên tên và nội dung của các `reducer function`.

  - Trong trường hợp của đoạn code bạn đưa ra, các `action creator` được tạo ra trong `slice` `blogSlice` sẽ có các tên tương ứng với các `reducer function` là `addPost`, `cancelEditingPost`, `deletePost`, `finishEditingPost`, và `startEditingPost`.

  - Tuy nhiên, để sử dụng được các `action creator` này trong các `component` khác, chúng ta cần phải `export` chúng ra ngoài bằng cú pháp:

  ```jsx
  export const { action1, action2, ... } = slice.actions
  ```

  - Vì vậy, dòng lệnh này:

  ```jsx
  export const {
    addPost,
    cancelEditingPost,
    deletePost,
    finishEditingPost,
    startEditingPost,
  } = blogSlice.actions;
  ```

  - Sẽ `export` các `action creator` của `slice` `blogSlice` để chúng ta có thể sử dụng chúng trong các component khác của ứng dụng.

## Đoạn code này được lấy từ `file` blog.slice.ts trong `folder` local-blog:

```jsx
const blogReducer = blogSlice.reducer;
export default blogReducer;
```

- Giải thích 2 dòng code này tại sao lại phải có ?

  - Trong `Redux Toolkit`, để sử dụng `slice`, ta cần phải trích xuất ra được `reducer` từ `slice` đó. Để làm điều này, ta sử dụng thuộc tính `reducer` của `slice`.

  - Trong trường hợp của đoạn code trên, ta đã tạo một `slice` là `blogSlice` bằng cách sử dụng hàm `createSlice`. Sau đó, ta trích xuất `reducer` từ `slice` bằng cách gán giá trị của thuộc tính `reducer` của `slice` cho một biến mới là `blogReducer`. Điều này giúp ta có thể sử dụng `reducer` này để đưa vào `store` của `Redux`.

  - Để sử dụng `reducer` này trong ứng dụng của ta, ta cần xuất nó ra bằng cách sử dụng từ khoá `export default`. Như vậy, khi `import reducer` của `slice` này ở nơi khác trong ứng dụng, ta có thể `import reducer` đó với cú pháp:

  ```jsx
  import blogReducer from './blogSlice'.
  ```

- Về phần thứ hai của câu hỏi của bạn, đó là về dòng code:

```jsx
export const {
  addPost,
  cancelEditingPost,
  deletePost,
  finishEditingPost,
  startEditingPost,
} = blogSlice.actions;
```

- Dòng đó là để `xuất` ra các `action creators` tương ứng với các `reducer` đã được định nghĩa trong `slice`, từ đó sử dụng chúng để gửi các `action` đến `reducer`. Ta sử dụng cú pháp này để `trích xuất` các `action creators` từ `slice` để có thể sử dụng chúng trong ứng dụng của ta.

## Đoạn code này được lấy từ `file` blog.slice.ts trong `folder` local-blog:

- Dòng code 1:

```jsx
export const {
  addPost,
  cancelEditingPost,
  deletePost,
  finishEditingPost,
  startEditingPost,
} = blogSlice.actions;
```

- Dòng code 2:

```jsx
const blogReducer = blogSlice.reducer;
```

- Trong 2 dòng code này nó có chứa: `blogSlice.reducer` và `blogSlice.actions`

- Như vậy thì chúng ta có `reducer` và `action` nó đều `trỏ` đến `1 vị trí` hả ? Ví dụ `deletePost` vừa là `reducer` vừa là `action` ?

  - Đúng vậy, khi sử dụng `createSlice` để tạo một `slice`, chúng ta có thể sử dụng `slice.actions` để truy cập vào các `action` được tạo ra bởi `slice` đó. Do đó, dòng code:

  ```jsx
  export const {
    addPost,
    cancelEditingPost,
    deletePost,
    finishEditingPost,
    startEditingPost,
  } = blogSlice.actions;
  ```

  - có nhiệm vụ `xuất` các `action` này để chúng ta có thể sử dụng trong các `component khác`.

  - Các `reducer function` được tạo ra bởi `createSlice` cũng được lưu trong `slice`, và có thể truy cập thông qua `slice.reducer`. Dòng code

  ```jsx
  const blogReducer = blogSlice.reducer;
  ```

  - có nhiệm vụ gán `reducer function` của `slice` này vào biến `blogReducer` để sử dụng trong việc tạo `store` trong `Redux`.

  - Vì các `action` và `reducer function` đều được tạo ra từ `slice` này, nên chúng ta có thể sử dụng cả `action` và `reducer function` trong một file khác, và chúng đều sẽ `trỏ` đến cùng một `slice`.

  - Ví dụ, `deletePost` vừa là một `reducer function` để xử lý `action`

  ```jsx
  blogSlice.actions.deletePost();
  ```

  - và cũng là một `action creator` để tạo ra `action`

  ```jsx
  dispatch(blogSlice.actions.deletePost());
  ```

## `export const` và `export default` nó có khác nhau cái gì không ?

- export const và export default là `khác nhau`.

- `export const` được sử dụng để xuất một `biến`, `hàm` hoặc `đối tượng` cụ thể từ một `module`, nó cho phép ta sử dụng `tên cụ thể` để `import` trong các `module` khác. Ví dụ:

```jsx
// file module.js
export const PI = 3.14;
export const double = (num) => num * 2;

// file main.js
import { PI, double } from "./module.js";

console.log(PI); // output: 3.14
console.log(double(5)); // output: 10
```

- `export default` cũng là một cách để `xuất` giá trị của một `module`, nhưng khác với `export const`, nó chỉ cho phép xuất một giá trị duy nhất từ một `module`. Và khi `import` giá trị đó trong một `module` khác, ta không cần phải sử dụng `tên cụ thể` của nó. Ví dụ:

```jsx
// file module.js
const PI = 3.14;
const double = (num) => num * 2;
export default { PI, double };

// file main.js
import myModule from "./module.js";

console.log(myModule.PI); // output: 3.14
console.log(myModule.double(5)); // output: 10
```

- Lưu ý rằng, ta có thể sử dụng `export default` và `export const` trong cùng một `module`. Tuy nhiên, khi import các giá trị đó vào module khác, ta phải tuân thủ cú pháp tương ứng.

## `reducers` là một đối tượng chứa các `reducer function` được tạo ra bởi `slice`... ?

- Vậy `slice` là cái nào ? Tôi chỉ thấy `createSlice` thôi. `Slice` là cái nào mà tôi không thấy trong đoạn code:

- Trong đoạn code trên, `slice` được tạo ra bởi hàm `createSlice`, và nó chứa thông tin về `name`, `initialState` và các `reducer functions`.

- Vì vậy, khi bạn sử dụng `createSlice`, bạn sẽ tạo ra một đối tượng `slice` để quản lý trạng thái (`state`) và các `logic` xử lý trên trạng thái của ứng dụng.

- Tóm lại, `slice` và `createSlice` là hai khái niệm liên quan đến `Redux Toolkit`, trong đó `createSlice` được sử dụng để tạo ra `slice` chứa các `reducer function` và `action creators` tương ứng, giúp cho việc quản lý trạng thái và xử lý logic trở nên đơn giản hơn.

## và trả về state mới của slice sau khi thực hiện xử lý `action`... ?

- Xử lý `action` là chỗ nào trong đoạn code, hãy nêu rõ và giải thích chi tiết nó:

  - Trong đoạn code này, xử lý `action` được thực hiện bởi các `reducer function` được định nghĩa trong đối tượng `reducers` của `createSlice`. Các `reducer function` này nhận vào `state` hiện tại của `slice` và một `action` tương ứng, sau đó thực hiện việc cập nhật `state` dựa trên thông tin trong `action`, và trả về `state` mới.

  - Ví dụ, trong đoạn code, `reducer function` là `deletePost` nhận vào `state` hiện tại và một `action` có `type` là `'blog/deletePost'` và `payload` là `id` của bài viết cần xóa. Sau đó, nó tìm vị trí của bài viết trong danh sách `postList` của `state` và xóa bài viết đó khỏi danh sách.

  - Cuối cùng, nó trả về `state` mới, đã được cập nhật. Tương tự, các `reducer function` khác cũng thực hiện các xử lý tương ứng với `action` tương ứng và trả về `state` mới.

## Trong đoạn code trên thì `action` nó tự động tạo `action creator` lun hả ?

- Đúng, `createSlice` tự động tạo các `action creators` tương ứng cho mỗi `reducer function` được định nghĩa trong `reducers`.

- Vì vậy, trong ví dụ trên, khi bạn định nghĩa `reducer function` `deletePost` trong `reducers`, `createSlice` sẽ tự động tạo ra một `action creator` tên là `deletePost` có thể được sử dụng để `dispatch` `action` tương ứng với `reducer function` này.

- Nếu bạn xem kỹ hơn trong đoạn code trên, bạn sẽ không thấy một đoạn mã nào liên quan đến việc tạo ra các `action creators`, nhưng bạn có thể sử dụng chúng bằng cách `import` các `action creators` từ `slice` tương ứng, ví dụ như sau:

```jsx
import { blogSlice } from "./blogSlice";

// Dispatch action by calling action creator
dispatch(blogSlice.actions.deletePost(postId));
```

- `blogSlice.actions.deletePost` sẽ trả về một `action` với `type` là `'blog/deletePost'` và `payload` tương ứng với đối số được truyền vào `action creator`. Việc tạo các `action creators` này được thực hiện `tự động` bởi `createSlice`.

## `action creator` có tên giống với `reducer function` lun hả ?

- Đúng, mặc định khi sử dụng `createSlice`, tên của `reducer function` trong `reducers` sẽ được sử dụng để đặt tên cho `action creator` tương ứng. Ví dụ, trong đoạn mã:

```jsx
const blogSlice = createSlice({
  name: "blog",
  initialState,
  reducers: {
    deletePost: (state, action) => {
      // ...
    },
  },
});
```

- `deletePost` là tên của `reducer function` và cũng là tên của `action creator` được tạo ra bởi `createSlice`. Nếu muốn đặt tên khác cho `action creator`, bạn có thể sử dụng cú pháp sau:

```jsx
const blogSlice = createSlice({
  name: "blog",
  initialState,
  reducers: {
    deletePostActionCreator: {
      reducer: (state, action) => {
        // ...
      },
      prepare: (postId) => ({ payload: postId }),
    },
  },
});
```

- Trong đoạn mã trên, `deletePostActionCreator` là tên của `action creator` được tạo ra bởi `createSlice`. Chú ý rằng bạn phải định nghĩa cả `reducer function` và `prepare method` (nếu cần) trong `object` tương ứng với `action creator` này.

## Tại sao `deletePost` vừa là `reducer function` vừa là `action creator` ?

- Trong `Redux Toolkit`, `createSlice` cho phép bạn định nghĩa `reducer function` và các `action creators` tương ứng trong một đối tượng gọi là `"reducers"`. Mỗi `reducer function` sẽ nhận vào `state` hiện tại và một `action` được `dispatch` và trả về một `state` mới nếu cần thiết. Trong khi đó, các `action creators` là các `hàm` giúp tạo ra các `action` với các `type` và `payload` tương ứng.

- Trong đoạn mã mà bạn đưa ra, `deletePost` là một `reducer function` được định nghĩa trong `reducers object` của `slice` thông qua `createSlice`. Nó nhận vào `state` hiện tại và một `action` có kiểu `PayloadAction<string>` (có chứa `payload` dạng `string`) và xử lý logic xóa bài đăng khỏi danh sách.

- Trong khi đó, `deletePost` cũng được tạo ra như một `action creator` thông qua `createSlice`, nó sẽ trả về một `action object` với kiểu tương ứng và `payload` là một chuỗi ID của bài đăng cần xóa.

# createSlice:

- `createSlice` là sự kết hợp của `createReducer` và `createAction`

- Mình khuyên các bạn nên dùng `createSlice` thay vì `createReducer` vì các bạn không cần tạo `action`, `action` sẽ tự động `generate` ra cho các bạn.

```jsx
import { createSlice } from "@reduxjs/toolkit";
import type { PayloadAction } from "@reduxjs/toolkit";

interface CounterState {
  value: number;
}

const initialState = { value: 0 } as CounterState;

const counterSlice = createSlice({
  name: "counter", // Đây là prefix cho action type của bạn
  initialState, // Giá trị khởi tạo state cho reducer, cũng có thể là function khởi tạo
  reducers: {
    // key name sẽ được dùng để generate ra action
    increment(state) {
      state.value++;
    },
    decrement(state) {
      state.value--;
    },
    incrementByAmount(state, action: PayloadAction<number>) {
      state.value += action.payload;
    },
  },
});

// export action được generate ra từ slice
export const { increment, decrement, incrementByAmount } = counterSlice.actions;

// export reducer được generate ra từ slice
export default counterSlice.reducer;
```

- Với `reducers` trên thì ta không dùng được với những trường hợp

  - default case
  - matcher case

=> Nên dùng `extraReducers` trong 2 trường hợp này

- Vì đặc tính tự động `generate` ra `action` khi dùng `reducers` nên nếu chúng ta sử dụng một thunk thì không nên check trong `reducers` mà hãy check trong `extraReducers`

## Hãy định nghĩa `extraReducers` ?

- `extraReducers` là một thuộc tính của đối tượng được truyền vào `createSlice()` để xác định các `reducer function` bổ sung khác, ngoài các `reducer function` được xác định trong thuộc tính `reducers`.

- Các `extraReducers` cho phép bạn sử dụng các `reducer function` đã được định nghĩa trước đó trong ứng dụng của bạn, không nhất thiết phải gắn chúng vào `slice` của bạn. Việc sử dụng `extraReducers` cho phép bạn tách biệt các `reducer function` ra khỏi `slice`, làm cho code của bạn trở nên dễ quản lý và tái sử dụng hơn.

- Mỗi `extraReducers` là một đối tượng (`object`) với các thuộc tính là các `action type` được định nghĩa, và các giá trị tương ứng là các `reducer function` để xử lý các `action` đó. Các `reducer function` được định nghĩa trong `extraReducers` cũng nhận vào `state` và `action` giống như `reducer function` trong `reducers` và trả về một `state` mới nếu cần thiết.

- Ví dụ, nếu bạn có một `action type` là `"users/deleteUser"`, bạn có thể định nghĩa một `reducer function` để xử lý `action` này và trả về một `state` mới, sau đó đưa nó vào `extraReducers` của `slice`. Khi một `action` có kiểu `"users/deleteUser"` được gửi đến `store`, `reducer function` của bạn sẽ được gọi và cập nhật `state` của `slice` tương ứng.

# extraReducers

- `extraReducers` cũng giống `reducers` nhưng nó sẽ không `generate` ra `actions`. `extraReducers` cho phép dùng một số tính năng như `addMatcher` hay `addDefaultCase`

> `extraReducers` chính xác giống như `reducer` trong `createReducer()`

```jsx
import { createAction, createSlice, Action, AnyAction } from "@reduxjs/toolkit";
const incrementBy = createAction<number>("incrementBy");
const decrement = createAction("decrement");

interface RejectedAction extends Action {
  error: Error;
}

function isRejectedAction(action: AnyAction): action is RejectedAction {
  return action.type.endsWith("rejected");
}

createSlice({
  name: "counter",
  initialState: 0,
  reducers: {},
  extraReducers: (builder) => {
    builder
      .addCase(incrementBy, (state, action) => {})

      .addCase(decrement, (state, action) => {})
      .addMatcher(isRejectedAction, (state, action) => {})
      .addDefaultCase((state, action) => {});
  },
});
```

- `extraReducers` cho phép dùng cú pháp "map object" nhưng với `typescript` thì chúng ta nên dùng `builder callback`

## Tóm lại khi nào dùng `reducers`, khi nào dùng `extraReducers`

- Dùng `reducers` khi muốn:

- generate ra action

- Dùng `extraReducers` khi:

  - Không muốn generate action
  - muốn dùng addMatcher, addDefaultCase
  - Khi dùng với createAsyncThunk

## Nên dùng `extraReducers` hay `reducer` trong createSlice ?

- Việc sử dụng `extraReducers` hay `reducers` trong `createSlice` phụ thuộc vào trường hợp cụ thể mà bạn đang giải quyết.

  - Nếu bạn đang tạo một `slice` mới và chỉ cần định nghĩa các `reducers` cho `slice` đó, thì sử dụng `reducers` là phù hợp nhất.

  - Tuy nhiên, nếu bạn muốn thực hiện các xử lý `logic` khác, ví dụ như cập nhật `state` của một `slice` khác, sau khi xử lý xong `action` của `slice` hiện tại, hoặc cần phải xử lý các `action` của `slice` khác, thì bạn có thể sử dụng `extraReducers`.

  - `extraReducers` cho phép bạn thêm các `reducers` cho các `action` của các `slice` khác, hoặc thực hiện các xử lý khác trên `state`.

- Tóm lại, việc sử dụng `extraReducers` hay `reducers` phụ thuộc vào nhu cầu của bạn.

## Trong các dự án thì `reducer` sử dụng nhiều hơn `extraReducers` đúng không ?

- Đúng, trong các dự án thường sử dụng `reducer` nhiều hơn `extraReducers` vì `reducer` là phần chính của `slice` và thường được sử dụng để xử lý các `action` tương ứng với `slice` đó.

- Tuy nhiên, khi cần xử lý các `action` liên quan đến nhiều `slice`, hoặc cần sử dụng các `logic` phức tạp hơn, sử dụng `extraReducers` có thể giúp quản lý `state` và xử lý `action` dễ dàng hơn.

- Tùy vào từng trường hợp cụ thể mà người lập trình có thể lựa chọn sử dụng `reducer` hoặc `extraReducers` trong `createSlice`.
