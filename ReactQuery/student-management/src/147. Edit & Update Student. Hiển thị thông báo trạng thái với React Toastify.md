## Đây là Docs tự research:

## Sử dụng react router kết hợp với react query ?

- Khi sử dụng `React Router` kết hợp với `React Query`, chúng ta có thể tận dụng các tính năng của cả hai thư viện để xây dựng ứng dụng web đáng tin cậy với phân trang và quản lý dữ liệu hiệu quả.

- Dưới đây là một ví dụ cơ bản về cách sử dụng `React Router` và `React Query` cùng nhau:

1. Cài đặt `React Router` và `React Query`:

```bash
npm install react-router-dom react-query
```

- Dòng code này được sử dụng để cài đặt hai thư viện `React Router` và `React Query` thông qua npm (Node Package Manager).

  - `npm` là một công cụ quản lý gói cho Node.js và npm Registry là một kho lưu trữ trực tuyến chứa các gói phần mềm JavaScript mà bạn có thể tải xuống và sử dụng trong dự án của mình.
  - `install` là một lệnh trong npm để cài đặt các gói phần mềm. Khi chạy lệnh install, npm sẽ tải xuống và cài đặt các gói được liệt kê trong dòng lệnh vào dự án của bạn.
  - `react-router-dom` là một thư viện hỗ trợ định tuyến (`routing`) trong React. Nó cung cấp các thành phần (`component`) và API để bạn có thể xác định các `route` và hiển thị các component tương ứng với từng `route`.
  - `react-query` là một thư viện quản lý trạng thái và truy vấn dữ liệu trong React. Nó cung cấp các hooks và API để bạn có thể thực hiện các truy vấn dữ liệu, lưu trữ kết quả và quản lý cache một cách dễ dàng.

- Khi chạy dòng lệnh trên, npm sẽ tìm kiếm và tải về các gói `react-router-dom` và `react-query` từ npm Registry, sau đó cài đặt chúng vào thư mục node_modules trong dự án của bạn. Sau khi quá trình cài đặt hoàn tất, bạn có thể sử dụng các thành phần và API của hai thư viện này trong ứng dụng React của mình.

2. Tạo các components và định nghĩa các route trong ứng dụng của bạn, ví dụ:

```jsx
import { BrowserRouter as Router, Switch, Route } from 'react-router-dom'
import { QueryClient, QueryClientProvider } from 'react-query'
import Home from './components/Home'
import PostList from './components/PostList'
import PostDetails from './components/PostDetails'

const queryClient = new QueryClient()

function App() {
  return (
    <QueryClientProvider client={queryClient}>
      <Router>
        <Switch>
          <Route exact path='/' component={Home} />
          <Route exact path='/posts' component={PostList} />
          <Route path='/posts/:id' component={PostDetails} />
        </Switch>
      </Router>
    </QueryClientProvider>
  )
}

export default App
```

- Đoạn code trên mô tả cách sử dụng `React Router` và `React Query` trong ứng dụng React. Dưới đây là giải thích từng phần của mã nguồn:

- `import { BrowserRouter as Router, Switch, Route } from 'react-router-dom':` Đây là cách import các thành phần từ thư viện `React Router`. `BrowserRouter` được đặt tên lại thành `Router` để sử dụng trong mã nguồn.

- `import { QueryClient, QueryClientProvider } from 'react-query':` Đây là cách import các thành phần từ thư viện `React Query`. `QueryClient` là một đối tượng quản lý trạng thái và cache của `React Query`, và `QueryClientProvider` là một thành phần cung cấp `QueryClient` cho các thành phần con trong ứng dụng.

- `const queryClient = new QueryClient():` Đây là khởi tạo một instance của `QueryClient`, một đối tượng quản lý trạng thái và cache của `React Query`. Instance này sẽ được sử dụng bởi `QueryClientProvider` để cung cấp cho các thành phần con trong ứng dụng.

- Trong hàm `App()`, chúng ta sử dụng `QueryClientProvider` để bao bọc ứng dụng và cung cấp `queryClient` cho các thành phần con. Điều này cho phép các thành phần con sử dụng `React Query` để thực hiện các truy vấn dữ liệu và quản lý cache.

- Chúng ta sử dụng `Router` để bao bọc các thành phần của ứng dụng và định tuyến giữa các trang. `Switch` là một thành phần của `React Router` dùng để chọn ra chỉ một `Route` phù hợp với URL hiện tại.

- Chúng ta định nghĩa các `Route` để xác định các URL và thành phần tương ứng để hiển thị. Trong ví dụ này, chúng ta có ba `Route`:

  - `exact path='/'` cho trang chủ (component `Home`).
  - `exact path='/posts'` cho danh sách bài viết (component `PostList`).
  - `path='/posts/:id'` cho chi tiết bài viết (component `PostDetails`), trong đó `:id` là một tham số động để xác định ID của bài viết.

- Cuối cùng, chúng ta xuất `App` để sử dụng trong ứng dụng chính.

- Với cấu hình này, `React Router` sẽ xác định các URL và hiển thị các thành phần tương ứng trong ứng dụng. `React Query` sẽ cung cấp khả năng thực hiện truy vấn dữ liệu và quản lý cache cho các thành phần con.

3. Trong các components của bạn, sử dụng các hooks của `React Query` để thực hiện các truy vấn dữ liệu và quản lý state của chúng, ví dụ:

```jsx
import { useQuery } from 'react-query'
import { useParams } from 'react-router-dom'

const fetchPost = async (postId) => {
  const response = await fetch(`api/posts/${postId}`)
  const data = await response.json()
  return data
}

function PostDetails() {
  const { id } = useParams()

  const { data, isLoading, isError, error } = useQuery(['post', id], () => fetchPost(id))

  if (isLoading) {
    return <div>Loading...</div>
  }

  if (isError) {
    return <div>Error: {error.message}</div>
  }

  return (
    <div>
      <h1>Post Details</h1>
      <p>ID: {data.id}</p>
      <p>Title: {data.title}</p>
      <p>Content: {data.content}</p>
    </div>
  )
}

export default PostDetails
```

- Đoạn mã trên mô tả một trang chi tiết bài viết trong ứng dụng sử dụng `React Query` và `React Router`.

  - `import { useQuery } from 'react-query'` và `import { useParams } from 'react-router-dom'`: Đây là cách import `useQuery` từ `React Query` để thực hiện truy vấn dữ liệu và `useParams` từ `React Router` để truy cập vào các tham số động trong URL.

  - `const fetchPost = async (postId) => { ... }`: Đây là hàm `fetchPost` để lấy dữ liệu của một bài viết từ API. Nó sử dụng `postId` làm tham số để xác định bài viết cần lấy. Hàm này sử dụng `fetch` để gửi yêu cầu GET đến API và trả về dữ liệu bài viết dưới dạng JSON. Dòng này sử dụng phương thức `json()` của đối tượng `response` để chuyển đổi dữ liệu trả về thành đối tượng (object) JavaScript. Hàm này trả về một Promise, vì vậy chúng ta sử dụng từ khóa await để đợi việc chuyển đổi dữ liệu thành công.

  - Trong component `PostDetails`, chúng ta sử dụng `useParams` để lấy tham số `id` từ URL. Tham số này xác định ID của bài viết được yêu cầu.

  - Chúng ta sử dụng `useQuery` để thực hiện truy vấn dữ liệu của bài viết. Chúng ta truyền vào một mảng `['post', id]` làm `queryKey`, trong đó `'post'` là một nhãn định danh cho truy vấn và `id` là ID của bài viết để xác định truy vấn duy nhất. Đối số thứ hai của `useQuery` là một hàm callback chứa logic để lấy dữ liệu bài viết từ API bằng cách sử dụng hàm `fetchPost` và truyền `id` làm tham số.

  - `useQuery` sẽ quản lý trạng thái truy vấn và cache dữ liệu. Chúng ta sử dụng các biến `data`, `isLoading`, `isError` và `error` được trả về từ `useQuery` để xử lý trạng thái của truy vấn. Các biến đó có sẵn trong `useQuery`.

  - Trong phần render, chúng ta kiểm tra trạng thái `isLoading` và `isError` để hiển thị thông báo tương ứng. Nếu đang tải dữ liệu, chúng ta hiển thị thông báo "Loading...". Nếu có lỗi, chúng ta hiển thị thông báo lỗi và hiển thị `error.message`, `error` là thông tin lỗi nó được trả về từ hook `useQuery`, nó có sẵn trong `isError`.

  - Nếu trạng thái truy vấn là thành công (`isLoading` và `isError` đều là `false`), chúng ta hiển thị chi tiết bài viết bằng cách truy cập vào `data`. Chúng ta sử dụng các trường `id`, `title` và `content` để hiển thị thông tin bài viết.

- Component `PostDetails` sẽ được sử dụng trong các `Route` để hiển thị trang chi tiết bài viết dựa trên `ID` được truyền qua URL.

✅✅ Tổng lại: Trên đây là một ví dụ cơ bản về việc sử dụng `React Router` kết hợp với `React Query` trong ứng dụng của bạn. Bằng cách sử dụng cả hai thư viện này, bạn có thể quản lý `routing` và truy vấn dữ liệu một cách hiệu quả, mang lại trải nghiệm người dùng tốt hơn và tối ưu hóa việc tải dữ liệu từ server.

## ❌❌ Lưu ý: Trong queryKey: ['post', id]. Cái này cần hiểu kỹ, bắt buộc phải hiểu: 👇👇👇

## ❌❌ Dưới đây là giải thích từng tham số trong queryKey: 👇👇👇

## Hãy giải thích về tham số đầu tiên ['post'] trong `queryKey` rõ ràng hơn ?

- Tham số đầu tiên `['post']` trong `queryKey` đại diện cho loại truy vấn. Nó được sử dụng để định danh loại dữ liệu bạn đang truy vấn.

- Trong trường hợp này, `'post'` là một chuỗi đại diện cho loại dữ liệu `"post"` mà bạn muốn truy vấn. Loại dữ liệu này có thể là bất kỳ chuỗi nào mà bạn tự đặt tên để phù hợp với mô hình dữ liệu của ứng dụng của bạn. Ví dụ: `'user'`, `'comment'`, `'product'`, vv.

- Ví dụ: Nếu ứng dụng của bạn là một blog và bạn muốn truy vấn các bài đăng, bạn có thể sử dụng `['post']` làm `queryKey` để xác định loại truy vấn là `"post"`.

- Mục đích của việc sử dụng loại truy vấn trong `queryKey` là để xác định và phân loại các truy vấn dựa trên loại dữ liệu. Khi bạn có nhiều loại dữ liệu khác nhau trong ứng dụng của mình, việc định danh mỗi loại dữ liệu thông qua `queryKey` giúp React Query quản lý và xử lý các truy vấn một cách chính xác.

## Tham số thứ 2 trong `queryKey` là `id`. Nó có nghĩa là sao. Tôi chưa hiểu lắm ?

- Tham số thứ hai trong `queryKey`, trong trường hợp của bạn là `id`, được sử dụng để xác định một giá trị đặc biệt (ví dụ: ID của bài viết) để truy vấn dữ liệu cụ thể từ server.

- Khi bạn truy vấn dữ liệu từ một nguồn dữ liệu như một API, thông thường bạn cần chỉ định một giá trị duy nhất để xác định dữ liệu cần lấy. Trong trường hợp của bạn là `queryKey: ['post', id]`, `id` đại diện cho giá trị đặc biệt (ví dụ: ID của bài viết) mà bạn muốn truy vấn.

- Với mỗi giá trị `id` khác nhau, bạn có thể truy vấn dữ liệu của các bài viết khác nhau từ server. Khi `id` thay đổi, React Query sẽ tự động gửi yêu cầu mới để lấy dữ liệu tương ứng từ server.

- Ví dụ: Nếu bạn muốn truy vấn dữ liệu bài viết có ID là 1, bạn sẽ sử dụng `queryKey: ['post', 1]`. Điều này cho biết bạn muốn truy vấn dữ liệu bài viết với `ID` là `1` từ server.

- Tóm lại, việc sử dụng `id` là một cách để xác định một giá trị đặc biệt và chỉ định dữ liệu cụ thể bạn muốn truy vấn từ server.

## Khi tôi khai báo như vậy `queryKey: ['post', id]` thì tôi sẽ lấy tất cả các bài viết trong `server` lun hả ?

- Không, khi bạn khai báo `queryKey: ['post', id]`, nghĩa là bạn chỉ định một `queryKey` cụ thể để truy vấn dữ liệu của một bài viết duy nhất từ server. `QueryKey` này gồm hai phần tử: `'post'` và `id`.

- Với cách truy vấn như vậy, React Query sẽ tự động thêm `queryKey` vào bộ nhớ cache để lưu trữ kết quả truy vấn của bài viết đó. Khi bạn thực hiện truy vấn với `queryKey` tương tự trong tương lai, React Query sẽ trước tiên kiểm tra xem liệu dữ liệu đã tồn tại trong cache hay chưa.

- Nếu dữ liệu đã tồn tại trong cache và chưa hết hạn (thời gian hết hạn được xác định bởi `staleTime`), React Query sẽ trả về dữ liệu từ cache mà không gửi yêu cầu mới đến server. Điều này giúp cải thiện hiệu suất ứng dụng.

- Nếu dữ liệu trong cache đã hết hạn hoặc chưa tồn tại trong cache, React Query sẽ tự động gửi yêu cầu mới đến server để lấy dữ liệu của bài viết tương ứng. Sau khi nhận được kết quả từ server, nó sẽ cập nhật cache và trả về kết quả cho bạn sử dụng.

- Vì vậy, với `queryKey: ['post', id]`, bạn chỉ truy vấn dữ liệu của một bài viết duy nhất có `ID` tương ứng từ server, không phải tất cả các bài viết.

## Có nghĩa là các bài viết của tôi đã `render` lên màn hình hết rồi. Và khi tôi khai báo như vậy thì có nghĩa là tôi `click` vào 1 bài viết bất kì trên màn hình, là `id` của bài viết đó được lưu trong `cache`. `queryKey: ['post', id]`, Vậy dòng này có `id` là `id` của mỗi bài viết mà tôi `click` vào đó hả ?

- Đúng, khi bạn khai báo `queryKey: ['post', id]`, trong đó `id` là `id` của bài viết mà bạn đang xem hoặc `click` vào. Điều này cho phép React Query xác định và lưu trữ kết quả truy vấn cho từng bài viết cụ thể trong cache.

- Khi bạn `click` vào một bài viết trên màn hình, bạn có thể truyền `id` của bài viết đó vào `queryKey` để thực hiện truy vấn dữ liệu của bài viết từ server. React Query sẽ sử dụng `queryKey` này để xác định kết quả truy vấn tương ứng trong cache.

- Ví dụ, nếu bạn `click` vào bài viết có `id` là `1`, bạn có thể sử dụng `queryKey: ['post', 1]` để truy vấn dữ liệu của bài viết đó. Khi đó, React Query sẽ kiểm tra cache và trả về kết quả truy vấn của bài viết có `id` là `1` nếu nó đã tồn tại trong cache và chưa hết hạn. Nếu chưa tồn tại hoặc đã hết hạn, React Query sẽ gửi yêu cầu mới đến server để lấy dữ liệu của bài viết và cập nhật cache.

- Việc sử dụng `queryKey` với `id` của bài viết giúp React Query quản lý và lấy dữ liệu tương ứng từ cache và server dễ dàng cho từng bài viết riêng biệt.

## Vậy tóm lại `['post', id]` trong `queryKey`, có nghĩa là khi các bài viết được lưu trong cache thì `'post'` đóng vai trò như `key`, còn `id` đóng vai trò như `value` đúng không ?

- Đúng, bạn đã hiểu đúng. Trong `queryKey: ['post', id]`, `'post'` đóng vai trò như một phần tử `key` và `id` đóng vai trò như một phần tử `value` trong mảng `queryKey`.

- Các mảng `queryKey` được sử dụng trong React Query như một cách để xác định duy nhất một truy vấn dữ liệu. Trong trường hợp này, `'post'` là phần tử `key` và đại diện cho loại dữ liệu bài viết trong truy vấn. `id` là phần tử `value` và đại diện cho giá trị cụ thể của `id` của bài viết mà bạn muốn truy vấn.

- Khi sử dụng `queryKey: ['post', id]`, React Query sẽ sử dụng cả `key` và `value` để xác định truy vấn cụ thể và quản lý kết quả truy vấn cho từng bài viết dựa trên `id` tương ứng.

## Hãy nêu khái niệm useMutation trong react query ?

- Trong React Query, `useMutation` là một hook dùng để thực hiện các yêu cầu thay đổi dữ liệu, chẳng hạn như tạo, cập nhật hoặc xóa (POST, PUT, DELETE) dữ liệu trên server (ngoại trừ GET). Nó cung cấp một cách tiện lợi để thực hiện các thao tác thay đổi dữ liệu và quản lý trạng thái của chúng.

- Khi sử dụng `useMutation`, bạn cần cung cấp một hàm gọi là `mutationFn`, đại diện cho yêu cầu thay đổi dữ liệu (ví dụ: gửi một POST request để tạo mới một bài viết). Khi gọi hàm `mutationFn`, React Query sẽ quản lý quá trình gửi yêu cầu, xử lý kết quả và cung cấp các trạng thái và phương thức hữu ích để tương tác với yêu cầu đó.

- Các trạng thái chính khi sử dụng `useMutation` bao gồm:

- `isLoading:` Đánh dấu xem yêu cầu đang được thực hiện hay không.
- `isError:` Đánh dấu xem yêu cầu có lỗi xảy ra hay không.
- `error:` Thông tin chi tiết về lỗi (nếu có).
- `data:` Dữ liệu trả về từ yêu cầu thành công (nếu có).
- `mutate:` Phương thức để gọi yêu cầu thay đổi dữ liệu.
- `reset:` Phương thức để đặt lại trạng thái yêu cầu.

- `useMutation` cũng cung cấp các callback như `onSuccess` và `onError`, cho phép bạn thực hiện các hành động tuỳ chỉnh sau khi yêu cầu thành công hoặc gặp lỗi.

## Ví dụ cơ bản về useMutation trong react query ?

- Dưới đây là một ví dụ cơ bản về cách sử dụng `useMutation` trong React Query để thực hiện một yêu cầu `POST` để tạo mới một bài viết:

```jsx
import { useMutation } from 'react-query'

const createPost = async (newPost) => {
  const response = await fetch('api/posts', {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json'
    },
    body: JSON.stringify(newPost)
  })

  if (!response.ok) {
    throw new Error('Failed to create post')
  }

  const data = await response.json()
  return data
}

function CreatePostForm() {
  const mutation = useMutation(createPost)

  const handleSubmit = (event) => {
    event.preventDefault()
    const formData = new FormData(event.target)
    const newPost = Object.fromEntries(formData.entries())
    mutation.mutate(newPost)
  }

  return (
    <form onSubmit={handleSubmit}>
      <input type='text' name='title' placeholder='Title' />
      <textarea name='content' placeholder='Content' />
      <button type='submit' disabled={mutation.isLoading}>
        {mutation.isLoading ? 'Creating...' : 'Create'}
      </button>
      {mutation.isError && <div>Error: {mutation.error.message}</div>}
      {mutation.isSuccess && <div>Post created successfully!</div>}
    </form>
  )
}
```

- Trong ví dụ này, chúng ta sử dụng `useMutation` để tạo một yêu cầu `POST` mới bằng cách cung cấp hàm `createPost` làm đối số cho `useMutation`. Sau đó, chúng ta sử dụng `mutation.mutate` để gọi yêu cầu thay đổi dữ liệu với dữ liệu mới từ `form`.

- `mutation.isLoading` được sử dụng để kiểm tra xem yêu cầu đang được thực hiện hay không để điều chỉnh trạng thái của nút `"Create"`.
- `mutation.isError` và `mutation.error.message` được sử dụng để hiển thị thông báo lỗi nếu có lỗi xảy ra.
- `mutation.isSuccess` được sử dụng để hiển thị thông báo thành công sau khi yêu cầu được thực hiện thành công.

- Đây chỉ là một ví dụ cơ bản về cách sử dụng `useMutation` và có thể được tùy chỉnh và mở rộng theo nhu cầu của ứng dụng.

## Giải thích đoạn code trên:

- Trong đoạn code trên, chúng ta sử dụng `useMutation` từ React Query để thực hiện một yêu cầu `POST` để tạo mới một bài viết.

- Hàm `createPost` là một hàm bất đồng bộ (`async`) được sử dụng để gửi yêu cầu `POST` tới API và trả về dữ liệu sau khi yêu cầu thành công. Nếu yêu cầu gặp lỗi, chúng ta sẽ `throw` một lỗi để xử lý sau này.

- Trong component `CreatePostForm`, chúng ta sử dụng `useMutation(createPost)` để khởi tạo một mutation instance. Mutation instance này cung cấp các thuộc tính và phương thức để theo dõi trạng thái của `mutation`.

- Trong hàm `handleSubmit`, chúng ta sử dụng `mutation.mutate(newPost)` để gọi yêu cầu tạo mới bài viết. `newPost` là đối tượng chứa thông tin bài viết từ `form`.

- Trong form, chúng ta sử dụng `onSubmit` để gọi hàm `handleSubmit` khi form được submit. Trạng thái `mutation.isLoading` được sử dụng để điều khiển trạng thái của nút `"Create"` và trạng thái này được sử dụng để hiển thị thông báo tương ứng (`"Creating..."` hoặc `"Create"`).

- `mutation.isError` được sử dụng để kiểm tra xem yêu cầu có gặp lỗi hay không. Nếu có lỗi, chúng ta hiển thị thông báo lỗi trong `div` có thông báo là Error.

- `mutation.isSuccess` được sử dụng để kiểm tra xem yêu cầu đã thành công hay không. Nếu thành công, chúng ta hiển thị thông báo thành công trong `div` có thông báo là Post created successfully!.

- Đoạn code trên chỉ là một ví dụ cơ bản để giải thích cách sử dụng `useMutation` trong React Query. Bạn có thể tùy chỉnh và mở rộng nó theo nhu cầu của ứng dụng.

## Ví dụ nâng cao về useMutation trong react query ?

- Dưới đây là một ví dụ nâng cao về việc sử dụng `useMutation` trong React Query để tạo, cập nhật và xóa dữ liệu:

```jsx
import React from 'react'
import { useMutation, useQueryClient } from 'react-query'

const TodoList = () => {
  const queryClient = useQueryClient()

  // Hàm gọi API để tạo mới một todo
  const createTodo = async (newTodo) => {
    const response = await fetch('api/todos', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json'
      },
      body: JSON.stringify(newTodo)
    })

    if (!response.ok) {
      throw new Error('Failed to create todo')
    }

    const data = await response.json()
    return data
  }

  // Hàm gọi API để cập nhật một todo
  const updateTodo = async (updatedTodo) => {
    const response = await fetch(`api/todos/${updatedTodo.id}`, {
      method: 'PUT',
      headers: {
        'Content-Type': 'application/json'
      },
      body: JSON.stringify(updatedTodo)
    })

    if (!response.ok) {
      throw new Error('Failed to update todo')
    }

    const data = await response.json()
    return data
  }

  // Hàm gọi API để xóa một todo
  const deleteTodo = async (todoId) => {
    const response = await fetch(`api/todos/${todoId}`, {
      method: 'DELETE'
    })

    if (!response.ok) {
      throw new Error('Failed to delete todo')
    }
  }

  const mutationOptions = {
    onSuccess: () => {
      // Khi thực hiện thành công create/update/delete, ta refetch lại dữ liệu để cập nhật UI
      queryClient.invalidateQueries('todos')
    }
  }

  const createMutation = useMutation(createTodo, mutationOptions)
  const updateMutation = useMutation(updateTodo, mutationOptions)
  const deleteMutation = useMutation(deleteTodo, mutationOptions)

  const handleCreateTodo = () => {
    const newTodo = { title: 'New Todo', completed: false }
    createMutation.mutate(newTodo)
  }

  const handleUpdateTodo = (todo) => {
    const updatedTodo = { ...todo, completed: !todo.completed }
    updateMutation.mutate(updatedTodo)
  }

  const handleDeleteTodo = (todoId) => {
    deleteMutation.mutate(todoId)
  }

  return (
    <div>
      <button onClick={handleCreateTodo}>Create Todo</button>
      <ul>
        {todos.map((todo) => (
          <li key={todo.id}>
            {todo.title} - {todo.completed ? 'Completed' : 'Not Completed'}
            <button onClick={() => handleUpdateTodo(todo)}>Toggle Complete</button>
            <button onClick={() => handleDeleteTodo(todo.id)}>Delete</button>
          </li>
        ))}
      </ul>
    </div>
  )
}

export default TodoList
```

- Trong ví dụ trên, chúng ta sử dụng `useMutation` để tạo ra ba biến mutation: `createMutation`, `updateMutation`, và `deleteMutation`. Mỗi biến mutation được khởi tạo với hàm tương ứng để gọi API tương ứng (tạo mới, cập nhật, xóa).

- `mutationOptions` được sử dụng để định cấu hình các hành vi sau khi mutation được thực hiện thành công. Trong ví dụ này, chúng ta sử dụng `onSuccess` để khi mutation hoàn thành thành công, ta sẽ làm tươi lại dữ liệu bằng cách gọi `queryClient.invalidateQueries('todos')`. Điều này giúp cập nhật UI với dữ liệu mới nhất.

- Khi người dùng thực hiện các hành động như tạo mới, cập nhật hoặc xóa một todo, ta gọi phương thức `mutate` trên các biến mutation tương ứng và chuyển tham số tương ứng (newTodo, updatedTodo, todoId).

- Khi mutation đang xử lý, bạn có thể sử dụng các thuộc tính như `isLoading`, `isError`, và `error` để hiển thị trạng thái và thông báo lỗi tương ứng.

- Ví dụ trên chỉ là một ví dụ nâng cao về việc sử dụng `useMutation` trong React Query. Bạn có thể tùy chỉnh nhiều hơn và áp dụng cho các trường hợp sử dụng thực tế khác nhau.

## Giải thích đoạn code trên:

```jsx
import React from 'react'
import { useMutation, useQueryClient } from 'react-query'
```

- Đoạn mã trên bao gồm hai import:

1. `React`: Đây là import cần thiết để sử dụng React trong ứng dụng của bạn. Mọi thành phần React đều phải import thư viện React trước khi sử dụng (hiện tại với phiên bản mới thì có thể không cần import dòng này).

2. `useMutation`, `useQueryClient` từ thư viện `react-query`: Đây là hai hook được cung cấp bởi React Query để thực hiện các hoạt động mutation và truy vấn trong ứng dụng.

- `useMutation`: Hook này cho phép bạn thực hiện các hoạt động mutation (thêm, sửa, xóa) và theo dõi trạng thái của chúng. Nó nhận vào một hàm mutation và trả về các giá trị và phương thức liên quan đến mutation.
- `useQueryClient`: Hook này cung cấp một instance của QueryClient, đại diện cho client của React Query. Bằng cách sử dụng `useQueryClient`, bạn có thể truy cập và thao tác với các hoạt động liên quan đến cache, như invalidate, refetch, remove các query, mutation và nhiều hơn nữa.

- Bạn có thể sử dụng `useMutation` để thực hiện các hoạt động mutation, và `useQueryClient` để thao tác với cache và các hoạt động liên quan trong React Query.

```jsx
const TodoList = () => {
  const queryClient = useQueryClient();
  ...
};
```

- Trong đoạn mã trên, chúng ta sử dụng hook `useQueryClient` từ thư viện React Query để tạo một instance của `QueryClient` và gán cho biến `queryClient`.

- `useQueryClient`: Hook này trả về một instance của `QueryClient` được sử dụng trong ứng dụng. `QueryClient` là một đối tượng quản lý trạng thái và cache cho các truy vấn và mutations trong React Query. Bằng cách sử dụng `useQueryClient`, chúng ta có thể truy cập và thực hiện các hoạt động liên quan đến cache như refetch, invalidate, remove queries, mutations và nhiều hơn nữa.

- Trong đoạn mã trên, chúng ta sử dụng `useQueryClient` để lấy một instance của QueryClient và gán nó cho biến `queryClient`. Sau đó, chúng ta có thể sử dụng biến `queryClient` để thực hiện các hoạt động liên quan đến cache, như làm mới lại dữ liệu, xóa dữ liệu, và các hoạt động khác mà cần truy cập vào cache của React Query.

```jsx
const createTodo = async (newTodo) => {
  const response = await fetch('api/todos', {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json'
    },
    body: JSON.stringify(newTodo)
  })

  if (!response.ok) {
    throw new Error('Failed to create todo')
  }

  const data = await response.json()
  return data
}

const updateTodo = async (updatedTodo) => {
  const response = await fetch(`api/todos/${updatedTodo.id}`, {
    method: 'PUT',
    headers: {
      'Content-Type': 'application/json'
    },
    body: JSON.stringify(updatedTodo)
  })

  if (!response.ok) {
    throw new Error('Failed to update todo')
  }

  const data = await response.json()
  return data
}

const deleteTodo = async (todoId) => {
  const response = await fetch(`api/todos/${todoId}`, {
    method: 'DELETE'
  })

  if (!response.ok) {
    throw new Error('Failed to delete todo')
  }
}
```

- Trong đoạn mã trên, chúng ta định nghĩa ba hàm `createTodo`, `updateTodo`, và `deleteTodo` để thực hiện các hoạt động tương ứng với việc tạo, cập nhật và xóa một todo từ API.

1. Hàm `createTodo`:

- Hàm này nhận vào một đối tượng `newTodo` chứa thông tin của todo mới.
- Sử dụng `fetch` để gửi một request POST tới endpoint `'api/todos'`.
- Trong phần cấu hình request:
  - Đặt method là `'POST'` để tạo một todo mới.
  - Đặt header là `'Content-Type': 'application/json'` để chỉ định kiểu dữ liệu gửi đi là JSON.
  - Chuyển đổi `newTodo` thành chuỗi JSON bằng cách sử dụng `JSON.stringify`.
  - Đặt body của request là chuỗi JSON chứa thông tin của `newTodo`.
- Sau đó, chúng ta chờ response từ server bằng cách sử dụng await.
- Nếu response không thành công (không có status code 2xx), ta throw một lỗi với thông báo 'Failed to create todo'.
- Nếu response thành công, ta parse response body từ kiểu dữ liệu chuỗi sang dữ liệu đối tượng (object) và trả về dữ liệu đó.

- Hàm createTodo được sử dụng để tạo một todo mới bằng cách gửi một request POST tới API và trả về dữ liệu của todo được tạo.

2. Hàm `updateTodo`:

- Trong đoạn code trên, chúng ta có hàm `updateTodo` để cập nhật một todo đã tồn tại bằng phương thức `PUT` trong API. Dưới đây là giải thích từng dòng code:

- `const updateTodo = async (updatedTodo) => {`: Đây là khai báo của hàm `updateTodo` nhận một tham số `updatedTodo`, đại diện cho thông tin todo cần cập nhật.

- `const response = await fetch(api/todos/${updatedTodo.id}, {`: Chúng ta sử dụng `fetch` để gửi một yêu cầu `PUT` đến API với URL được xây dựng từ `api/todos/` và `updatedTodo.id` để chỉ định todo cần cập nhật.

- `method: 'PUT'`: Đây là phần của cấu hình yêu cầu gửi đi, chỉ định rằng chúng ta đang sử dụng phương thức `PUT` để cập nhật todo.

- `headers: { 'Content-Type': 'application/json' }`: Đây là phần cấu hình cho tiêu đề của yêu cầu gửi đi. Trong trường hợp này, chúng ta đang chỉ định rằng dữ liệu được gửi đi dưới dạng JSON.

- `body: JSON.stringify(updatedTodo)`: Đây là phần cấu hình cho nội dung yêu cầu gửi đi. Chúng ta sử dụng JSON.stringify để chuyển đổi đối tượng `updatedTodo` thành chuỗi JSON trước khi gửi đi (`.stringify` là chuyển từ `object` sang `string`).

- `if (!response.ok) { throw new Error('Failed to update todo') }`: Chúng ta kiểm tra xem phản hồi từ API có thành công hay không bằng cách kiểm tra giá trị `response.ok`. Trong trường hợp không thành công, chúng ta ném một lỗi để xử lý sau này.

- `const data = await response.json()`: Nếu phản hồi từ API thành công, chúng ta sử dụng `response.json()` để chuyển đổi nội dung phản hồi từ JSON sang đối tượng JavaScript. Kết quả chuyển đổi được lưu trữ trong biến `data`.

- `return data`: Cuối cùng, chúng ta trả về dữ liệu đã cập nhật từ API thông qua biến `data`.

- Tóm lại, hàm `updateTodo` thực hiện gửi yêu cầu `PUT` đến API để cập nhật todo đã tồn tại, và sau đó trả về dữ liệu cập nhật thành công để sử dụng trong quá trình hiển thị hoặc xử lý tiếp theo.

3. Hàm `deleteTodo`:

- Trong đoạn code trên, chúng ta có hàm `deleteTodo` để xóa một todo thông qua phương thức `DELETE` trong API. Dưới đây là giải thích từng dòng code:

- `const deleteTodo = async (todoId) => {`: Đây là khai báo của hàm bất đồng bộ `deleteTodo` nhận một tham số `todoId`, đại diện cho ID của todo cần xóa. Từ khóa `async` được sử dụng để định nghĩa một hàm bất đồng bộ, cho phép sử dụng `await` để đợi cho đến khi một hoạt động bất đồng bộ hoàn thành.

- `const response = await fetch(api/todos/${todoId}, {`: Chúng ta sử dụng `fetch` để gửi một yêu cầu `DELETE` đến API với URL được xây dựng từ `api/todos/` và `todoId` để chỉ định todo cần xóa.

- `method: 'DELETE'`: Đây là phần của cấu hình yêu cầu gửi đi, chỉ định rằng chúng ta đang sử dụng phương thức `DELETE` để xóa todo.

- `if (!response.ok) { throw new Error('Failed to delete todo') }`: Chúng ta kiểm tra xem phản hồi từ API có thành công hay không bằng cách kiểm tra giá trị `response.ok`. Trong trường hợp không thành công, chúng ta ném một lỗi để xử lý sau này.

- Tóm lại, hàm `deleteTodo` thực hiện gửi yêu cầu `DELETE` đến API để xóa todo dựa trên `todoId`. Nếu phản hồi từ API thành công, không có dữ liệu trả về, ngược lại, nếu không thành công, chúng ta ném một lỗi để xử lý sau này.

```jsx
const mutationOptions = {
  onSuccess: () => {
    queryClient.invalidateQueries('todos')
  }
}
```

- Trong đoạn code trên, chúng ta có biến `mutationOptions` để cấu hình tùy chọn cho mutation. Dưới đây là giải thích chi tiết:

- `onSuccess: () => { queryClient.invalidateQueries('todos') }`: Đây là một callback được gọi khi mutation thành công. Trong trường hợp này, chúng ta sử dụng `queryClient.invalidateQueries('todos')` để làm mới tất cả các queries có liên quan đến danh sách `todos`. `queryClient` là một instance của `QueryClient` được tạo ra trước đó và được sử dụng để tương tác với React Query. Hàm `invalidateQueries` được sử dụng để đánh dấu các queries liên quan là không hợp lệ, và sẽ được gọi lại khi có yêu cầu mới để cập nhật dữ liệu.

- `queryClient.invalidateQueries('todos')`, dòng này có nghĩa là khi dữ liệu thay đổi thì sẽ gọi lại và sẽ cập nhật lại dữ liệu mới hả ?

  - Đúng, dòng code `queryClient.invalidateQueries('todos')` được sử dụng để thông báo cho React Query rằng dữ liệu có tên `'todos'` đã thay đổi và cần phải được cập nhật lại.

  - Khi gọi `invalidateQueries('todos')`, React Query sẽ xóa dữ liệu hiện có của query có tên `'todos'` khỏi cache. Sau đó, khi truy cập lại query đó, React Query sẽ tự động thực hiện một request mới để lấy dữ liệu mới nhất từ server và cập nhật lại cache.

  - Điều này cho phép đồng bộ dữ liệu giữa client và server khi có những thay đổi xảy ra, đảm bảo rằng dữ liệu được hiển thị trên giao diện người dùng luôn là phiên bản mới nhất.

- Tóm lại, khi mutation thành công, `onSuccess` sẽ được gọi và chúng ta sử dụng `queryClient.invalidateQueries('todos')` để làm mới các queries liên quan đến danh sách `todos`, để đảm bảo rằng dữ liệu được cập nhật và phản ánh sự thay đổi mới nhất.

```jsx
const createMutation = useMutation(createTodo, mutationOptions)
const updateMutation = useMutation(updateTodo, mutationOptions)
const deleteMutation = useMutation(deleteTodo, mutationOptions)
```

- Trong đoạn code trên, chúng ta đang sử dụng ba hook `useMutation` để tạo các mutations cho việc tạo, cập nhật và xóa todos. Hãy giải thích từng dòng code một:

- `const createMutation = useMutation(createTodo, mutationOptions)`: Đây là cách chúng ta sử dụng `useMutation` để tạo mutation cho hành động tạo mới `todo`. `createTodo` là hàm chúng ta đã định nghĩa trước đó, đại diện cho hành động tạo mới một `todo`. `mutationOptions` là đối tượng cấu hình cho mutation, chúng ta đã giải thích ở trên. Kết quả của hook `useMutation` được gán vào biến `createMutation`, và biến này sẽ chứa các thông tin về trạng thái và phương thức liên quan đến mutation tạo mới.

- Tương tự, `const updateMutation = useMutation(updateTodo, mutationOptions)` và `const deleteMutation = useMutation(deleteTodo, mutationOptions)` tạo các mutations cho hành động cập nhật và xóa `todo`. `updateTodo` và `deleteTodo` là các hàm chúng ta đã định nghĩa trước đó, đại diện cho hành động cập nhật và xóa `todo` tương ứng.

- Tóm lại, ba dòng code trên tạo ra ba mutations sử dụng `useMutation` với các hàm xử lý tương ứng và cấu hình chung được chia sẻ thông qua `mutationOptions`. Các biến `createMutation`, `updateMutation` và `deleteMutation` chứa thông tin và phương thức liên quan đến các mutations tương ứng.

```jsx
const handleCreateTodo = () => {
  const newTodo = { title: 'New Todo', completed: false }
  createMutation.mutate(newTodo)
}

const handleUpdateTodo = (todo) => {
  const updatedTodo = { ...todo, completed: !todo.completed }
  updateMutation.mutate(updatedTodo)
}

const handleDeleteTodo = (todoId) => {
  deleteMutation.mutate(todoId)
}
```

- Trong đoạn code trên, chúng ta định nghĩa các hàm xử lý sự kiện để gọi các mutations tương ứng. Hãy giải thích từng hàm một:

- `handleCreateTodo`: Đây là hàm xử lý sự kiện để tạo một `todo` mới. Trong hàm này, chúng ta đầu tiên tạo một `newTodo` với các thuộc tính `title` là "New Todo" và `completed` là false. Sau đó, chúng ta gọi phương thức `mutate` của `createMutation` và truyền vào `newTodo` để thực hiện hành động tạo mới `todo`.

- `handleUpdateTodo`: Đây là hàm xử lý sự kiện để cập nhật một `todo` đã tồn tại. Hàm này nhận vào một `todo` là tham số. Trong hàm này, chúng ta tạo một `updatedTodo` bằng cách sao chép toàn bộ thuộc tính của `todo` và thay đổi giá trị của thuộc tính `completed` bằng phép đảo ngược (`!todo.completed`). Sau đó, chúng ta gọi phương thức `mutate` của `updateMutation` và truyền vào `updatedTodo` để thực hiện hành động cập nhật todo.

- `handleDeleteTodo`: Đây là hàm xử lý sự kiện để xóa một `todo` đã tồn tại. Hàm này nhận vào một `todoId` là tham số. Trong hàm này, chúng ta gọi phương thức `mutate` của `deleteMutation` và truyền vào `todoId` để thực hiện hành động xóa `todo`.

- Tóm lại, các hàm xử lý sự kiện trên được sử dụng để gọi các mutations tương ứng thông qua việc gọi phương thức `mutate` của các biến `createMutation`, `updateMutation` và `deleteMutation`. Việc gọi phương thức `mutate` này sẽ kích hoạt quá trình thực hiện mutations tương ứng và cập nhật dữ liệu trong cache của React Query.

```jsx
return (
  <div>
    <button onClick={handleCreateTodo}>Create Todo</button>
    <ul>
      {todos.map((todo) => (
        <li key={todo.id}>
          {todo.title} - {todo.completed ? 'Completed' : 'Not Completed'}
          <button onClick={() => handleUpdateTodo(todo)}>Toggle Complete</button>
          <button onClick={() => handleDeleteTodo(todo.id)}>Delete</button>
        </li>
      ))}
    </ul>
  </div>
)
```

- Đoạn code trên render ra một danh sách các Todo và cung cấp các nút để tạo, cập nhật và xóa Todo. Hãy giải thích từng phần một:

- `<button onClick={handleCreateTodo}>Create Todo</button>`: Đây là một nút "Create Todo" và khi người dùng nhấn vào nút này, sự kiện `onClick` sẽ được kích hoạt và gọi đến hàm `handleCreateTodo()` để tạo một Todo mới.

- `<ul>`: Đây là một danh sách không sắp xếp (unordered list) để hiển thị danh sách các Todo.

- `{todos.map((todo) => (...)}`: Đây là một vòng lặp, lặp qua mảng `todos` để tạo ra các phần tử `<li>` tương ứng với mỗi Todo trong danh sách.

- `<li key={todo.id}>`: Đây là một phần tử trong danh sách Todo và có thuộc tính `key` được gán bằng giá trị `todo.id` để định danh duy nhất cho mỗi Todo.

- `{todo.title} - {todo.completed ? 'Completed' : 'Not Completed'}`: Hiển thị tiêu đề của Todo và trạng thái hoàn thành của nó.

- `<button onClick={() => handleUpdateTodo(todo)}>Toggle Complete</button>`: Đây là một nút "Toggle Complete" và khi người dùng nhấn vào nút này, sự kiện `onClick` sẽ được kích hoạt và gọi đến hàm `handleUpdateTodo()` với tham số là Todo tương ứng để cập nhật trạng thái hoàn thành của nó.

- `<button onClick={() => handleDeleteTodo(todo.id)}>Delete</button>`: Đây là một nút "Delete" và khi người dùng nhấn vào nút này, sự kiện `onClick` sẽ được kích hoạt và gọi đến hàm `handleDeleteTodo()` với tham số là `todo.id` để xóa Todo tương ứng.

- Tổng cộng, đoạn code trên hiển thị danh sách Todo và cung cấp các nút để tạo, cập nhật và xóa Todo. Khi người dùng thực hiện các hành động này, các hàm xử lý sự kiện tương ứng (`handleCreateTodo`, `handleUpdateTodo`, `handleDeleteTodo`) sẽ được gọi để thực hiện các mutations và cập nhật dữ liệu.

## Hãy nêu khái niệm useQuery trong react query ?

- Trong React Query, `useQuery` là một hook được sử dụng để thực hiện yêu cầu lấy dữ liệu từ một nguồn bên ngoài, chẳng hạn như API, và theo dõi trạng thái của yêu cầu.

- Khi sử dụng `useQuery`, bạn cần cung cấp các thông tin cần thiết như `queryKey` và `queryFn`. `queryKey` là một giá trị duy nhất được sử dụng để định danh cho query, xác định loại dữ liệu được yêu cầu. `queryFn` là một hàm mà React Query sẽ gọi để thực hiện yêu cầu lấy dữ liệu.

- Khi yêu cầu được gửi đi, `useQuery` sẽ tự động theo dõi trạng thái của yêu cầu và cung cấp các biến như `data`, `isLoading`, `isError`, `error`, `isFetching`, `refetch` và nhiều biến khác để giúp bạn xử lý và hiển thị dữ liệu và trạng thái tương ứng.

- Một số khái niệm quan trọng liên quan đến `useQuery` trong React Query:

- `data`: Dữ liệu trả về từ yêu cầu lấy dữ liệu. Nó sẽ được cập nhật khi yêu cầu thành công.
- `isLoading`: Xác định xem yêu cầu đang trong quá trình tải hay không.
- `isError`: Xác định xem yêu cầu có gặp lỗi hay không.
- `error`: Thông tin về lỗi nếu yêu cầu gặp lỗi.
- `isFetching`: Xác định xem yêu cầu đang trong quá trình fetch hay không, bao gồm cả khi sử dụng refetch.
- `refetch`: Một hàm dùng để gửi lại yêu cầu lấy dữ liệu.
- `onSuccess`: Một hàm callback được gọi khi yêu cầu thành công.
- `onError`: Một hàm callback được gọi khi yêu cầu gặp lỗi.

- Sử dụng `useQuery`, bạn có thể tạo các query instances để thực hiện các yêu cầu lấy dữ liệu khác nhau trong ứng dụng và quản lý trạng thái của chúng.

## Ví dụ cơ bản về useQuery trong react query ?

- Dưới đây là một ví dụ cơ bản về cách sử dụng `useQuery` trong React Query để lấy danh sách các bài viết từ một API:

```jsx
import { useQuery } from 'react-query'

const fetchPosts = async () => {
  const response = await fetch('api/posts')
  const data = await response.json()
  return data
}

function PostList() {
  const { data, isLoading, isError, error } = useQuery('posts', fetchPosts)

  if (isLoading) {
    return <div>Loading...</div>
  }

  if (isError) {
    return <div>Error: {error.message}</div>
  }

  return (
    <div>
      <h1>Post List</h1>
      <ul>
        {data.map((post) => (
          <li key={post.id}>{post.title}</li>
        ))}
      </ul>
    </div>
  )
}
```

- Trong ví dụ trên, chúng ta sử dụng `useQuery` để thực hiện yêu cầu lấy danh sách các bài viết từ API. Chúng ta cung cấp một `queryKey` (trong trường hợp này là `'posts'`) để định danh cho query và một `queryFn` (trong trường hợp này là hàm `fetchPosts`) để thực hiện yêu cầu.

- Khi yêu cầu được gửi đi, `useQuery` sẽ tự động theo dõi trạng thái của yêu cầu và cung cấp các biến như `data`, `isLoading`, `isError`, `error` để xử lý và hiển thị dữ liệu tương ứng. Trong ví dụ này, chúng ta kiểm tra trạng thái của yêu cầu và hiển thị dữ liệu, thông báo tải dữ liệu hoặc thông báo lỗi tương ứng.

- Với `useQuery`, chúng ta có thể dễ dàng thực hiện các yêu cầu lấy dữ liệu và quản lý trạng thái của chúng trong ứng dụng React một cách dễ dàng và mạnh mẽ.

## Định danh trong query trong queryKey của React Query là sao ?

- Trong ngữ cảnh của React Query, "định danh" (identity) là một cách để xác định một truy vấn dữ liệu một cách duy nhất. Nó được sử dụng để phân biệt các truy vấn khác nhau và quản lý kết quả truy vấn.

- Định danh thường được xác định bằng cách sử dụng một giá trị duy nhất như một khóa (`key`). Trong React Query, `queryKey` có thể được sử dụng để xác định định danh cho một truy vấn. `queryKey` có thể là một mảng (array) chứa các giá trị như tên truy vấn và các tham số đi kèm, hoặc có thể là một giá trị duy nhất đại diện cho truy vấn.

- Khi định danh của một truy vấn thay đổi, React Query sẽ hiểu rằng đó là một truy vấn mới và sẽ thực hiện truy vấn lại từ `server` thay vì sử dụng kết quả từ bộ nhớ `cache`. Điều này đảm bảo rằng bạn nhận được dữ liệu mới nhất từ `server` khi có sự thay đổi trong định danh của truy vấn.

## Mỗi giá trị định danh đó thì nó sẽ gán cho 1 id. Có nghĩa là 1 dữ liệu được gán cho 1 id, có 10 dữ liệu thì sẽ gán cho 10 id hả ?

- Đúng, trong React Query, mỗi giá trị định danh (`queryKey`) sẽ được gán cho một ID duy nhất để xác định truy vấn dữ liệu tương ứng. Khi thực hiện một truy vấn, React Query sẽ sử dụng định danh để xác định xem truy vấn đã được thực hiện trước đó hay chưa.

- Ví dụ, nếu bạn có 10 dữ liệu và muốn lấy thông tin chi tiết về từng dữ liệu, bạn có thể sử dụng `queryKey` với một giá trị duy nhất (ví dụ: `'post'`) và kết hợp nó với ID của từng bài viết để tạo ra một định danh duy nhất cho từng truy vấn. Điều này cho phép React Query quản lý các kết quả truy vấn riêng biệt cho từng bài viết.

- Ví dụ: `['post', 1]`, `['post', 2]`, `['post', 3]`, v.v. là các định danh duy nhất cho các truy vấn lấy thông tin từng bài viết tương ứng.

## Ví dụ nâng cao về useQuery trong react query ?

- Dưới đây là một ví dụ nâng cao về việc sử dụng `useQuery` trong React Query:

```jsx
import { useQuery } from 'react-query'

const fetchUser = async (userId) => {
  const response = await fetch(`api/users/${userId}`)

  if (!response.ok) {
    throw new Error('Failed to fetch user')
  }

  const data = await response.json()
  return data
}

const UserProfile = ({ userId }) => {
  const { data, isLoading, isError, error } = useQuery(['user', userId], () => fetchUser(userId))

  if (isLoading) {
    return <div>Loading...</div>
  }

  if (isError) {
    return <div>Error: {error.message}</div>
  }

  return (
    <div>
      <h2>User Profile</h2>
      <p>Name: {data.name}</p>
      <p>Email: {data.email}</p>
      <p>Location: {data.location}</p>
    </div>
  )
}

export default UserProfile
```

- Trong ví dụ trên, chúng ta có một thành phần (component) `UserProfile` nhận vào một `userId` làm prop. Chúng ta sử dụng `useQuery` để lấy dữ liệu người dùng từ API bằng cách gọi hàm `fetchUser` trong hàm truyền vào của `useQuery`.

- Trong `useQuery`, chúng ta truyền một mảng dependencies là `['user', userId]` để định danh yêu cầu dữ liệu người dùng. Điều này cho phép chúng ta sử dụng cùng một hàm `fetchUser` cho nhiều yêu cầu khác nhau bằng cách định danh chúng với các `key` khác nhau.
- Khi yêu cầu dữ liệu đang được thực hiện, `isLoading` sẽ là `true`, cho phép chúng ta hiển thị thông báo "Loading..." để người dùng biết rằng dữ liệu đang được tải.
- Nếu có lỗi xảy ra trong quá trình yêu cầu dữ liệu, `isError` sẽ là `true` và `error` sẽ chứa thông tin lỗi. Chúng ta hiển thị thông báo lỗi cho người dùng.
- Nếu yêu cầu dữ liệu thành công, chúng ta sử dụng `data` để truy cập và hiển thị thông tin người dùng như tên (`name`), `email` và địa chỉ (`address`).

- Với `useQuery`, React Query sẽ tự động quản lý việc tạo và lưu trữ cache dữ liệu, tự động làm mới dữ liệu theo các tiêu chí `dependencies` và cung cấp các tính năng như `prefetching` và `refetching` dữ liệu. Điều này giúp tối ưu hiệu suất ứng dụng và cung cấp trải nghiệm người dùng tốt hơn.

## Giải thích chi tiết đoạn code trên:

- Đoạn mã trên là một ví dụ về cách sử dụng thư viện React Query để tải dữ liệu từ một API và hiển thị nó trên giao diện. Dưới đây là phân tích từng đoạn mã:

```jsx
import { useQuery } from 'react-query'
```

- Dòng code `import { useQuery } from 'react-query';`: được sử dụng để import hook `useQuery` từ thư viện React Query. Hook này cho phép chúng ta thực hiện các yêu cầu dữ liệu và quản lý cache trong ứng dụng React.

- `useQuery` là một hook mạnh mẽ được cung cấp bởi React Query để thực hiện yêu cầu dữ liệu. Nó nhận vào hai tham số chính là `queryKey`, `queryFn`.

```jsx
const fetchUser = async (userId) => {
  const response = await fetch(`api/users/${userId}`)

  if (!response.ok) {
    throw new Error('Failed to fetch user')
  }

  const data = await response.json()
  return data
}
```

- Đoạn code trên định nghĩa một hàm `fetchUser` để thực hiện yêu cầu lấy dữ liệu (GET) người dùng từ API.

- Đầu tiên, hàm này nhận một tham số `userId`, đại diện cho ID của người dùng mà chúng ta muốn lấy thông tin.

- Tiếp theo, chúng ta sử dụng `fetch` để gửi yêu cầu HTTP GET đến đường dẫn `api/users/${userId}` để lấy thông tin người dùng từ API. Đây là một endpoint giả định trong ví dụ của chúng ta. Bạn có thể thay thế nó bằng endpoint thực tế trong ứng dụng của bạn.

- Chúng ta sử dụng `response.ok` để kiểm tra xem yêu cầu đã thành công hay không. Nếu yêu cầu không thành công (`response.ok` là `false`), chúng ta ném một lỗi bằng cách sử dụng `throw new Error('Failed to fetch user')`.

- Nếu yêu cầu thành công, chúng ta sử dụng `response.json()` để chuyển đổi phản hồi từ dạng JSON sang dữ liệu đối tượng (`object`) JavaScript. Đây là phần dữ liệu mà chúng ta mong đợi từ yêu cầu người dùng.

- Kiểu dữ liệu JSON là kiểu này:

```
"
  {
    "name": "John Doe",
    "age": 30,
    "email": "john.doe@example.com"
  }
"
```

- Khi chuyển đổi từ kiểu JSON sang Object là kiểu này:

```jsx
{
  name: "John Doe",
  age: 30,
  email: "john.doe@example.com"
}
```

- Cuối cùng, chúng ta trả về dữ liệu đã được chuyển đổi. Kết quả này sẽ được sử dụng bởi hook `useQuery` để cung cấp dữ liệu người dùng cho ứng dụng.

- Tóm lại, hàm `fetchUser` này thực hiện yêu cầu lấy dữ liệu (GET) người dùng từ API và trả về dữ liệu sau khi nó đã được chuyển đổi từ JSON sang dữ liệu đối tượng (Object) JavaScript.

```jsx
const UserProfile = ({ userId }) => {
  const { data, isLoading, isError, error } = useQuery(['user', userId], () => fetchUser(userId))

  if (isLoading) {
    return <div>Loading...</div>
  }

  if (isError) {
    return <div>Error: {error.message}</div>
  }

  return (
    <div>
      <h2>User Profile</h2>
      <p>Name: {data.name}</p>
      <p>Email: {data.email}</p>
      <p>Location: {data.location}</p>
    </div>
  )
}
```

- Đoạn code trên là một component `UserProfile` sử dụng `useQuery` để lấy thông tin người dùng từ API và hiển thị trên giao diện người dùng.

- Trong component, chúng ta sử dụng `useQuery` để tạo một truy vấn có tên là `'user'` và `userId` là tham số phụ thuộc. Điều này đảm bảo rằng truy vấn sẽ được tự động kích hoạt mỗi khi `userId` thay đổi.

  - `['user', userId]` là `queryKey`. Đây là một mảng chứa các tham số được sử dụng để định danh cho truy vấn (query). Trong trường hợp này, `queryKey` được sử dụng để định danh cho một truy vấn để lấy thông tin của một người dùng cụ thể (`userId`).

  - `() => fetchUser(userId)` là `queryFn`. Đây là một hàm được sử dụng để thực hiện truy vấn và trả về kết quả. Trong trường hợp này, `queryFn` được sử dụng để gọi hàm `fetchUser` để tải thông tin của người dùng từ API. Phương thức `useQuery` sẽ tự động gọi `queryFn` khi cần thiết để tải lại dữ liệu hoặc khi truy vấn chưa được thực hiện. Kết quả của `queryFn` sẽ được lưu trữ trong `data`.

- Tham số thứ hai của `useQuery` là một hàm `callback`, trong đó chúng ta gọi hàm `fetchUser(userId)` để lấy thông tin người dùng từ API.
- Kết quả truy vấn được lưu trong các biến `data`, `isLoading`, `isError`, `error`.
- Nếu đang trong quá trình tải dữ liệu (`isLoading` là `true`), chúng ta hiển thị một thông báo "Loading...".
- Nếu có lỗi trong quá trình truy vấn (`isError` là `true`), chúng ta hiển thị thông báo lỗi kèm theo thông tin lỗi từ `error.message`.
- Nếu không có lỗi và dữ liệu đã được tải thành công, chúng ta hiển thị thông tin người dùng như tên, email và vị trí (`name`, `email`, `location`).

- Đoạn code trên cho phép lấy dữ liệu từ API và tự động cập nhật khi userId thay đổi. Nó cũng xử lý các trạng thái tải dữ liệu và xử lý lỗi để cung cấp trải nghiệm người dùng mượt mà.

```jsx
export default UserProfile
```

- `export default` được sử dụng để xuất các thành phần của `module` mà có thể được sử dụng bên ngoài `module` này. Trong trường hợp này, `UserProfile` là một React function component đã được định nghĩa trong `module` hiện tại, và `export default UserProfile` được sử dụng để xuất component này ra bên ngoài `module` để có thể được sử dụng trong các `module` khác của ứng dụng React.

- Khi một `module` được xuất dưới dạng `export default`, nó có thể được nhập vào một `module` khác bằng cách sử dụng `import` mà không cần đặt tên cho thành phần được xuất.

- Ví dụ về import module này vào component khác:

```jsx
import UserProfile from './UserProfile'
```

- Trong ví dụ này, module `UserProfile` được import vào module hiện tại, và được lưu trữ trong biến `UserProfile`. Biến này sẽ chứa component `UserProfile`, và có thể được sử dụng để hiển thị component này trên giao diện của ứng dụng React.

## Tổng quan về useMutation và useQuery trong react query ?

- `useMutation` và `useQuery` là hai hook quan trọng trong React Query. Dưới đây là tổng quan về cả hai hook:

1. `useMutation`:

- `useMutation` được sử dụng để thực hiện các yêu cầu `thay đổi` dữ liệu như tạo mới, cập nhật hoặc xóa dữ liệu từ server.
- Nó nhận vào một hàm `mutationFn` (hoặc promise) để thực hiện yêu cầu thay đổi dữ liệu.

- `useMutation` cung cấp các biến và phương thức để quản lý trạng thái của yêu cầu, như `isLoading`, `isError`, `error`, `data`, `mutate`, `reset`, và nhiều hơn nữa.

  - `mutate`: Phương thức này dùng để kích hoạt quá trình mutation. Bạn có thể truyền vào dữ liệu cần thay đổi và nó sẽ gửi yêu cầu tới server để thực hiện mutation.
  - `isLoading, isError, isSuccess`: Các trạng thái này xác định trạng thái hiện tại của quá trình mutation (đang tải, có lỗi, thành công).
  - `error`: Nếu có lỗi xảy ra trong quá trình mutation, thông tin lỗi sẽ được lưu trong biến error.
  - `reset`: Phương thức này dùng để đặt lại trạng thái của mutation về trạng thái ban đầu.

- Bằng cách sử dụng `mutate`, chúng ta có thể gửi yêu cầu thay đổi dữ liệu một cách bất đồng bộ và quản lý trạng thái yêu cầu dễ dàng.

2. `useQuery`:

- `useQuery` được sử dụng để thực hiện các yêu cầu `lấy` dữ liệu từ server.
- Nó nhận vào một `queryKey` để định danh cho yêu cầu và một `queryFn` (hoặc promise) để thực hiện yêu cầu lấy dữ liệu.

- `useQuery` cung cấp các biến và phương thức để quản lý trạng thái của yêu cầu, như `isLoading`, `isError`, `error`, `data`, `refetch`, `reset`, và nhiều hơn nữa.

  - `data`: Dữ liệu trả về từ server được lưu trong biến `data`.
  - `isLoading, isError, isSuccess`: Các trạng thái này xác định trạng thái hiện tại của quá trình truy vấn (đang tải, có lỗi, thành công).
  - `error`: Nếu có lỗi xảy ra trong quá trình truy vấn, thông tin lỗi sẽ được lưu trong biến error.
  - `refetch`: Phương thức này dùng để làm mới truy vấn, gửi yêu cầu lên server để lấy dữ liệu mới.
  - `invalidateQueries`: Phương thức này dùng để đánh dấu các truy vấn liên quan là không hợp lệ, yêu cầu truy vấn lại dữ liệu từ server.

- Khi sử dụng `useQuery`, React Query sẽ tự động quản lý bộ nhớ cache và sử dụng dữ liệu đã lưu trữ trong cache nếu có, giúp tối ưu hiệu suất và giảm số lần gửi yêu cầu lặp lại.

- Cả hai hook đều giúp chúng ta quản lý trạng thái yêu cầu dễ dàng và tự động, hỗ trợ tải dữ liệu bất đồng bộ, quản lý cache và cung cấp các phương thức tiện ích để thao tác với dữ liệu. Sử dụng `useMutation` và `useQuery` trong React Query giúp tạo ra trải nghiệm tốt hơn cho việc làm việc với dữ liệu trong ứng dụng React.

## Tóm lại là khi sử dụng `useMutation` là bao gồm POST, PUT, DELETE. Còn khi sử dụng `useQuery` là sử dụng GET ?

- Đúng, khi sử dụng `useMutation` trong React Query, chúng ta thường sử dụng nó để thực hiện các yêu cầu `thay đổi` dữ liệu như tạo mới (POST), cập nhật (PUT/PATCH) và xóa (DELETE). Điều này là do các yêu cầu này thường liên quan đến việc `thay đổi` dữ liệu trên server.

- Trong khi đó, khi sử dụng `useQuery`, chúng ta thường sử dụng nó để thực hiện yêu cầu `lấy` dữ liệu từ server, điển hình là yêu cầu GET. Chúng ta sử dụng `useQuery` để lấy dữ liệu từ server và quản lý trạng thái của yêu cầu, bao gồm trạng thái tải dữ liệu (`isLoading`), trạng thái lỗi (`isError`), dữ liệu đã được lấy (`data`), và nhiều thuộc tính và phương thức khác.

- Tuy nhiên, trong thực tế, không có quy tắc cứng và nhanh chóng rằng `useMutation` chỉ được sử dụng cho POST, PUT và DELETE, và `useQuery` chỉ được sử dụng cho GET. Chúng ta có thể sử dụng cả hai hook để thực hiện các yêu cầu tùy chỉnh và phù hợp với nhu cầu cụ thể của ứng dụng của chúng ta. Mục đích chính của React Query là hỗ trợ việc làm việc với dữ liệu bất đồng bộ và quản lý trạng thái của các yêu cầu dễ dàng và hiệu quả.

## React Toastify là gì ?

- React Toastify là một thư viện React được sử dụng để hiển thị các thông báo (toasts) trong ứng dụng web. Nó cung cấp các thành phần và API đơn giản để tạo ra các thông báo đẹp, linh hoạt và dễ sử dụng.

- Với React Toastify, bạn có thể hiển thị các thông báo tạm thời trong góc màn hình, thông báo lỗi, thông báo thành công, thông báo cảnh báo và nhiều loại thông báo khác. Bạn có thể tùy chỉnh các thông báo theo ý muốn, bao gồm nội dung, kiểu, thời gian tồn tại, hành động, hình ảnh và nhiều thuộc tính khác.

- React Toastify cung cấp một API đơn giản để tạo ra các thông báo bằng cách sử dụng các hàm như `toast.success()`, `toast.error()`, `toast.warning()` và `toast.info()`. Nó cũng cung cấp các hook như `useToast()` để tạo ra các thông báo từ các thành phần React.

- Thư viện này giúp cải thiện trải nghiệm người dùng và tăng tính tương tác trong ứng dụng của bạn bằng cách cung cấp các thông báo hữu ích và hấp dẫn cho người dùng.

## cho ví dụ cơ bản về React Toastify ?

- Để sử dụng React Toastify, bạn cần cài đặt thư viện `react-toastify` và import các thành phần cần thiết. Dưới đây là một ví dụ cơ bản về việc sử dụng React Toastify để hiển thị thông báo thành công:

```jsx
import React from 'react'
import { toast, ToastContainer } from 'react-toastify'
import 'react-toastify/dist/ReactToastify.css'

const ExampleComponent = () => {
  const handleButtonClick = () => {
    toast.success('Thao tác thành công!')
  }

  return (
    <div>
      <button onClick={handleButtonClick}>Hiển thị thông báo</button>
      <ToastContainer />
    </div>
  )
}

export default ExampleComponent
```

- Trong ví dụ trên, chúng ta import thành phần `toast` và `ToastContainer` từ `react-toastify`. Hàm `toast.success()` được sử dụng để hiển thị thông báo thành công khi người dùng nhấp vào nút. `ToastContainer` được đặt trong thành phần để chứa và hiển thị các thông báo.

- Bạn có thể thay đổi kiểu thông báo bằng cách sử dụng các hàm khác như `toast.error()` (thông báo lỗi), `toast.warning()` (thông báo cảnh báo) và `toast.info()` (thông báo thông tin). Bạn cũng có thể tùy chỉnh nội dung và các thuộc tính khác của thông báo theo ý muốn.

- Lưu ý rằng bạn cần import CSS của React Toastify (`react-toastify/dist/ReactToastify.css`) để đảm bảo giao diện của thông báo được hiển thị đúng cách.

- Đây chỉ là một ví dụ đơn giản về cách sử dụng React Toastify. Thư viện này còn rất nhiều tính năng và tùy chọn để bạn khám phá và tùy chỉnh theo nhu cầu của mình.

## Đây là Docs của Được Dev:

TIếp nối video lần trước, lần này chúng ta sẽ thực hiện chức năng Edit và Delete Student bằng React Query nhé.

💓Kiến thức các bạn sẽ được học trong video này:

🎉 Sử dụng react router kết hợp với react query
🎉 useMutation và useQuery
🎉 React Toastify

🕰️Nội dung chính

```bash
00:00 - Edit Student
15:50 - Sử dụng React Toastify
18:40 - Xử lý lỗi submit từ server trả về
22:11 - Delete Student
```
