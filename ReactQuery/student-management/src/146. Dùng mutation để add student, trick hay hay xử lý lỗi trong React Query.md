## Đây là Docs tự research:

## HTTP Request là gì? Các phương thức HTTP request ?

- HTTP (Hypertext Transfer Protocol) là một giao thức truyền tải dữ liệu qua mạng được sử dụng rộng rãi trên internet. Nó định nghĩa cách các máy tính giao tiếp và trao đổi thông tin với nhau.

- Trong HTTP, các phương thức (methods) được sử dụng để chỉ định mục đích hoặc hành động mà một yêu cầu HTTP muốn thực hiện trên tài nguyên.

- Dưới đây là một số phương thức cơ bản trong HTTP:

1. `GET`: Sử dụng để lấy thông tin từ một tài nguyên đã cho. Yêu cầu GET không thay đổi dữ liệu trên máy chủ và chỉ trả về dữ liệu đã được yêu cầu.

2. `POST`: Sử dụng để gửi dữ liệu mới đến máy chủ để tạo một tài nguyên mới. Yêu cầu POST thường đi kèm với dữ liệu được gửi trong phần thân của yêu cầu.

3. `PUT`: Sử dụng để cập nhật hoặc tạo mới một tài nguyên với nội dung đã được cung cấp. Yêu cầu PUT thay đổi hoặc tạo mới tài nguyên theo đường dẫn được chỉ định.

4. `DELETE`: Sử dụng để xóa một tài nguyên đã cho. Yêu cầu DELETE xóa tài nguyên theo đường dẫn được chỉ định.

- Ngoài ra, còn có các phương thức khác như `OPTIONS`, `HEAD`, `PATCH`, `TRACE`, `CONNECT` được sử dụng cho các mục đích đặc biệt trong HTTP.

- Khi gửi một yêu cầu HTTP, phương thức được xác định trong phần đầu yêu cầu gọi là "phương thức yêu cầu" (`request method`). Máy chủ nhận yêu cầu và xử lý tương ứng với phương thức đó để trả về kết quả hoặc thực hiện hành động tương ứng.

- Các phương thức HTTP cung cấp khả năng thực hiện các hành động khác nhau trên tài nguyên, cho phép giao tiếp và thay đổi dữ liệu trên web.

## ❌❌ Lưu ý: GET khác với POST trong HTTP là gì ? cái nào khi sử dụng thì thông tin hiện lên đường dẫn url ? cài nào không hiện thông tin lên url ?

- Trong HTTP, `GET` và `POST` là hai phương thức khác nhau được sử dụng để truyền tải dữ liệu giữa máy chủ và trình duyệt web.

- Phương thức `GET` được sử dụng để yêu cầu tài nguyên từ máy chủ web và trả về nội dung của tài nguyên đó. Khi sử dụng phương thức `GET`, thông tin yêu cầu của bạn được đính kèm vào URL dưới dạng `query string`, do đó thông tin sẽ hiển thị trên đường dẫn URL.

- Phương thức `POST` được sử dụng để gửi dữ liệu đến máy chủ web (`client gửi đến server`) để thực hiện một hành động nhất định. Thông tin yêu cầu của bạn được gửi trong phần `body` của yêu cầu HTTP và không hiển thị trên đường dẫn URL.

- Vì vậy, khi sử dụng phương thức `GET`, thông tin yêu cầu sẽ được hiển thị trên URL, trong khi đó khi sử dụng phương thức `POST`, thông tin sẽ không được hiển thị trên URL. Phương thức `POST` thường được sử dụng khi bạn cần gửi dữ liệu lớn hoặc dữ liệu nhạy cảm, và không muốn thông tin đó được hiển thị trên đường dẫn URL.

## Hãy định nghĩa hàm useMutation trong React Query ?

- Trong React Query, hàm `useMutation` nhận vào một hàm thực thi thao tác thay đổi dữ liệu, thường là một hàm gọi API để tạo, cập nhật hoặc xóa dữ liệu. Hàm này sẽ được gọi khi bạn muốn thực hiện một thao tác thay đổi dữ liệu.

- Cú pháp của `useMutation` như sau:

```jsx
const mutation = useMutation(mutationFunction, options)
```

- `mutationFunction` là một hàm mà khi gọi, nó sẽ thực hiện thao tác thay đổi dữ liệu. Hàm này thường gọi API để gửi yêu cầu tới máy chủ.
- `options` (tùy chọn) là một đối tượng chứa các tuỳ chọn để tùy chỉnh hành vi của `useMutation`. Đây là một đối tượng có thể bao gồm các thuộc tính như `onSuccess`, `onError`, `onSettled`, `onMutate`, `retry`, v.v.

- Khi sử dụng `useMutation`, nó sẽ trả về một đối tượng `mutation` với các thuộc tính và phương thức hữu ích để quản lý trạng thái và kết quả của thao tác thay đổi dữ liệu. Một số thuộc tính quan trọng của đối tượng `mutation` bao gồm:

  - `mutate`: Một hàm được sử dụng để kích hoạt thực thi thao tác thay đổi dữ liệu.
  - `isLoading`: Một giá trị `boolean` cho biết liệu thao tác đang được thực hiện hay không.
  - `isError`: Một giá trị `boolean` cho biết liệu có xảy ra lỗi trong quá trình thực hiện thao tác hay không.
  - `isSuccess`: Một giá trị `boolean` cho biết liệu thao tác đã thành công hay không.
  - `data`: Dữ liệu trả về từ thao tác thay đổi dữ liệu (nếu thành công).

- Qua đó, `useMutation` cho phép bạn dễ dàng quản lý trạng thái và kết quả của thao tác thay đổi dữ liệu trong React Query.

## Thuộc tính trong React Query bao gồm những gì ?

- Trong React Query, khi sử dụng `useMutation`, thuộc tính được truyền vào trong đối tượng `mutationFunction` là một đối tượng JSON (JavaScript Object Notation) chứa các cặp khóa-giá trị (key-value) của dữ liệu bạn muốn thay đổi. Ví dụ:

```jsx
const mutation = useMutation(createUser, options)
```

- Trong ví dụ trên, `createUser` là một hàm thực hiện thao tác tạo người dùng (hoặc thay đổi dữ liệu khác). Đối tượng JSON chứa dữ liệu cần thay đổi sẽ được truyền vào hàm này.

- Ví dụ, nếu bạn muốn tạo một người dùng mới với tên là "David", tuổi là 25, bạn có thể truyền một đối tượng JSON như sau:

```jsx
const newUser = {
  name: 'David',
  age: 25
  // các thuộc tính khác nếu cần
}

const mutation = useMutation(() => createUser(newUser), options)
```

- Trong đó, `newUser` là một đối tượng JSON chứa các cặp khóa-giá trị. Mỗi khóa đại diện cho một thuộc tính (ví dụ: 'name', 'age') và giá trị tương ứng là dữ liệu bạn muốn thay đổi (ví dụ: 'David', 25).

- Khi thực hiện thao tác thay đổi dữ liệu bằng cách gọi `mutation.mutate()`, đối tượng `mutationFunction` (trong ví dụ là `createUser`) sẽ được gọi và nhận đối tượng JSON này làm đối số để thực hiện thao tác thay đổi dữ liệu.

## Ví dụ trên là truyền 1 dữ liệu tĩnh rồi. Hãy cho ví dụ khác truyền vào một đối tượng động ?

- Tất nhiên! Dưới đây là một ví dụ khác, truyền vào một đối tượng động khi sử dụng `useMutation` trong React Query:

- Gồm có 2 đoạn code: (chý đọc từ trên xuống dưới)

```jsx
const mutation = useMutation(updateUser, {
  onSuccess: () => {
    // Xử lý thành công sau khi mutation hoàn thành
    console.log('Cập nhật người dùng thành công')
  },
  onError: (error) => {
    // Xử lý khi có lỗi xảy ra trong quá trình mutation
    console.error('Lỗi khi cập nhật người dùng:', error)
  }
})

const handleUpdateUser = () => {
  const updatedUser = {
    id: 1,
    name: 'John Doe',
    age: 30
    // các thuộc tính khác nếu cần
  }

  mutation.mutate(updatedUser)
}
```

- Trong ví dụ trên, chúng ta định nghĩa một hàm `handleUpdateUser` để thực hiện việc cập nhật người dùng. Tham số đầu tiên là đối tượng `updatedUser` chứa thông tin về người dùng muốn cập nhật, bao gồm `id`, `name`, `age` và các thuộc tính khác (nếu cần). Tham số thứ hai đó là option của hàm `useMutation`. Tham số option này có thể tuỳ chỉnh hành vi và xử lý sau khi `mutation` hoàn thành hoặc xảy ra lỗi.

- Khi gọi `mutation.mutate(updatedUser)`, đối tượng `updatedUser` sẽ được truyền vào `mutationFunction` (trong ví dụ là `updateUser`) để thực hiện thao tác cập nhật dữ liệu.

- Trong `mutationFunction` (`updateUser`), bạn có thể sử dụng thông tin từ đối tượng `updatedUser` để thực hiện các thao tác cần thiết, ví dụ:

```jsx
const updateUser = async (user) => {
  try {
    const response = await axios.put(`/api/users/${user.id}`, user)
    return response.data
  } catch (error) {
    throw new Error('Failed to update user')
  }
}
```

- Trong ví dụ trên, chúng ta sử dụng `axios` để gửi yêu cầu PUT đến API với đường dẫn `/api/users/{userId}` để cập nhật thông tin người dùng. Đối tượng `user` được truyền vào yêu cầu PUT chính là `updatedUser` mà chúng ta đã truyền vào `mutation.mutate()`.

- Hy vọng rằng ví dụ này giúp bạn hiểu cách truyền một đối tượng động khi sử dụng `useMutation` trong React Query.

## Giải thích 2 đoạn code ở trên:

✅ Đoạn code thứ 1 (giải thích):

```jsx
const mutation = useMutation(updateUser, {
  onSuccess: () => {
    // Xử lý thành công sau khi mutation hoàn thành
    console.log('Cập nhật người dùng thành công')
  },
  onError: (error) => {
    // Xử lý khi có lỗi xảy ra trong quá trình mutation
    console.error('Lỗi khi cập nhật người dùng:', error)
  }
})

const handleUpdateUser = () => {
  const updatedUser = {
    id: 1,
    name: 'John Doe',
    age: 30
    // các thuộc tính khác nếu cần
  }

  mutation.mutate(updatedUser)
}
```

- Trong đoạn code trên, chúng ta sử dụng `useMutation` từ React Query để tạo một `mutation` (thay đổi dữ liệu) mới.

- `useMutation` nhận vào hai tham số chính: `updateUser` và `options`.

  - `updateUser` là một hàm được định nghĩa để thực hiện việc cập nhật thông tin người dùng. Đối tượng `updatedUser` được truyền vào hàm này là đối tượng chứa thông tin cập nhật, bao gồm `id`, `name`, `age` và các thuộc tính khác (nếu có).

  - `options` là một đối tượng chứa các tuỳ chọn cho `mutation`. Trong đoạn code trên, bạn có thể thêm các tuỳ chọn như `onSuccess`, `onError`, hoặc `onSettled` để xử lý các trạng thái hoặc hành động liên quan đến `mutation`.

  - Trong ví dụ trên, chúng ta đã thêm một đối tượng `options` vào hàm `useMutation`. Trong options, chúng ta đã sử dụng hai thuộc tính:

  - `onSuccess`: Đây là một hàm được gọi khi mutation hoàn thành thành công. Trong ví dụ này, chúng ta chỉ đơn giản ghi thông báo "Cập nhật người dùng thành công" vào console. Bạn có thể thay đổi hoặc mở rộng hành động tương ứng với thành công của mutation.

  - `onError`: Đây là một hàm được gọi khi có lỗi xảy ra trong quá trình mutation. Trong ví dụ này, chúng ta ghi thông báo lỗi và hiển thị nội dung lỗi trong console. Bạn có thể thay đổi hoặc xử lý các tình huống lỗi khác tùy theo yêu cầu của bạn.

  - Với việc thêm options vào `useMutation`, bạn có thể tuỳ chỉnh hành vi và xử lý sau khi mutation hoàn thành hoặc xảy ra lỗi.

- Tiếp theo, chúng ta định nghĩa hàm `handleUpdateUser` để thực hiện việc cập nhật người dùng. Trong hàm này, chúng ta khai báo một đối tượng `updatedUser` với các thuộc tính cần cập nhật. Trong ví dụ này, chúng ta cập nhật người dùng có `id` là 1, `name` là 'John Doe', và `age` là 30. Bạn có thể thêm hoặc chỉnh sửa các thuộc tính khác theo nhu cầu.

- Cuối cùng, chúng ta gọi `mutation.mutate(updatedUser)` để kích hoạt mutation và thực hiện việc cập nhật người dùng. Đối tượng `updatedUser` sẽ được truyền vào hàm `updateUser` để thực hiện thao tác cập nhật thông tin người dùng.

- Sau khi mutation hoàn thành, React Query sẽ tự động quản lý trạng thái và cung cấp các giá trị như `isLoading`, `isError`, `isSuccess` để bạn có thể xử lý kết quả hoặc hiển thị giao diện tương ứng.

✅ Đoạn code thứ 2 (giải thích):

```jsx
const updateUser = async (user) => {
  try {
    const response = await axios.put(`/api/users/${user.id}`, user)
    return response.data
  } catch (error) {
    throw new Error('Failed to update user')
  }
}
```

- Trong đoạn code trên, chúng ta định nghĩa một hàm `updateUser` để thực hiện việc cập nhật thông tin người dùng bằng cách gửi một yêu cầu PUT đến endpoint `/api/users/{user.id}` trên máy chủ.

  - Đầu tiên, chúng ta sử dụng thư viện Axios để gửi yêu cầu PUT bằng cách sử dụng phương thức `axios.put()`. Đối số đầu tiên của phương thức này là URL endpoint, trong đó chúng ta sử dụng `user.id` để xác định người dùng cần cập nhật. Đối số thứ hai là `user`, đại diện cho đối tượng chứa thông tin cần cập nhật (trong ví dụ này là `updatedUser`).

  - Sau khi gửi yêu cầu PUT, chúng ta chờ đợi phản hồi từ máy chủ bằng cách sử dụng từ khóa `await`. Phản hồi được lưu trữ trong biến `response`.
  - Nếu yêu cầu được xử lý thành công và nhận được phản hồi từ máy chủ, chúng ta trả về dữ liệu từ phản hồi bằng cách sử dụng `response.data`.
  - Trong trường hợp xảy ra lỗi trong quá trình gửi yêu cầu hoặc nhận phản hồi, một ngoại lệ (exception) sẽ được ném ra bằng cách sử dụng từ khóa `throw new Error()`. Trong đoạn code trên, chúng ta ném ra một ngoại lệ với thông báo `'Failed to update user'`.

- Khi sử dụng `useMutation` và truyền hàm `updateUser` vào, React Query sẽ quản lý quá trình `mutation`, xử lý trạng thái và cung cấp các giá trị như `isLoading`, `isError`, `isSuccess` và `data` để xử lý kết quả hoặc hiển thị giao diện tương ứng.

## Hãy định nghĩa hàm useQuery trong React Query ?

👉 Phần này giải thích trong bài học trước rất kỹ, bạn có thể mở lại file bài cũ và xem lại nhé !!

👉 Trong bài này chỉ nêu sơ qua khái niệm để nắm lại kiến thức cũ thôi nhé !!

- Trong React Query, hàm `useQuery` là một hook dùng để thực hiện các truy vấn dữ liệu. Nó cho phép bạn lấy dữ liệu từ một nguồn dữ liệu (chẳng hạn như API) và tự động quản lý việc cập nhật, caching và tái sử dụng dữ liệu.

- Hàm `useQuery` có các tham số sau:

1. `queryKey` (required): Một giá trị hoặc mảng giá trị đại diện cho khóa truy vấn. Khóa truy vấn xác định loại dữ liệu và thông tin cần thiết để lấy dữ liệu, chẳng hạn như tên API endpoint hoặc các tham số truy vấn.

2. `queryFn` (required): Một hàm không đồng bộ (async) hoặc hàm trả về một Promise, được sử dụng để thực hiện truy vấn và lấy dữ liệu từ nguồn dữ liệu. Hàm này sẽ được gọi bởi React Query để lấy dữ liệu và trả về kết quả.

3. `config` (optional): Một đối tượng cấu hình bổ sung để điều chỉnh hành vi của truy vấn. Các tùy chọn cấu hình bao gồm:

   - `enabled`: Xác định trạng thái có cho phép truy vấn chạy hay không. Mặc định là true.

   - `staleTime`: Thời gian (milliseconds) mà dữ liệu được coi là "stale" (cũ) trước khi truy vấn tự động fetch dữ liệu mới từ nguồn dữ liệu. Mặc định là 0 (không sử dụng caching).

   - `cacheTime`: Thời gian (milliseconds) mà dữ liệu được lưu trữ trong cache trước khi nó bị coi là "expired" (hết hạn) và truy vấn sẽ fetch dữ liệu mới. Mặc định là `Infinity` (lưu trữ vĩnh viễn).

   - `onSuccess`: Một hàm callback được gọi khi truy vấn thành công và có dữ liệu mới. Hàm này có tham số là dữ liệu mới.

   - `onError`: Một hàm callback được gọi khi truy vấn gặp lỗi. Hàm này có tham số là đối tượng lỗi.

   - Các tùy chọn khác như `retry`, `retryDelay`, `onSettled`,...

- Hàm `useQuery` trả về một đối tượng query, chứa các thông tin liên quan đến trạng thái và dữ liệu của truy vấn, cũng như các phương thức để tương tác với truy vấn như `refetch`, `fetchMore`, `remove`,...

- Bạn có thể sử dụng đối tượng query này để hiển thị trạng thái của truy vấn và dữ liệu tương ứng trong giao diện người dùng. Khi có sự thay đổi trong truy vấn (ví dụ: thành công, lỗi, cập nhật dữ liệu), React Query sẽ tự động cập nhật giao diện của bạn.

## hãy cho ví dụ về useQuery có các tham số cơ bản ?

- Dưới đây là một ví dụ về cách sử dụng `useQuery` trong React Query để lấy danh sách bài viết từ một API:

```jsx
import { useQuery } from 'react-query'

const fetchPosts = async () => {
  const response = await fetch('api/posts')
  const data = await response.json()
  return data
}

function PostList() {
  const { data, isLoading, isError, error } = useQuery('posts', fetchPosts)

  if (isLoading) {
    return <div>Loading...</div>
  }

  if (isError) {
    return <div>Error: {error.message}</div>
  }

  return (
    <div>
      <h1>Post List</h1>
      <ul>
        {data.map((post) => (
          <li key={post.id}>{post.title}</li>
        ))}
      </ul>
    </div>
  )
}
```

- Trong ví dụ này, chúng ta sử dụng `useQuery` để lấy danh sách bài viết từ API. Đối số đầu tiên của `useQuery` là `queryKey`, trong trường hợp này là `'posts'`, đại diện cho loại dữ liệu và thông tin cần thiết để lấy danh sách bài viết. Đối số thứ hai là `queryFn`, một hàm không đồng bộ để thực hiện truy vấn và lấy dữ liệu từ API.

- Đối tượng trả về từ `useQuery` chứa các trạng thái và dữ liệu của truy vấn, bao gồm `data` (danh sách bài viết), `isLoading` (trạng thái đang tải), `isError` (trạng thái lỗi), và `error` (đối tượng lỗi). Chúng ta sử dụng các trạng thái này để hiển thị nội dung tương ứng trong giao diện người dùng.

- Khi truy vấn được thực hiện, React Query sẽ tự động quản lý việc lấy dữ liệu, caching và cập nhật giao diện khi có sự thay đổi trong trạng thái và dữ liệu của truy vấn.

## Giải thích code:

-

## Hãy cho ví dụ về useQuery có đầy đủ các phương thức queryKey, queryFn, staleTime, cacheTime, onSuccess, onError, refetch... ?

- Dưới đây là một ví dụ về cách sử dụng `useQuery` với các phương thức và tùy chọn (optional) khác nhau trong React Query:

```jsx
import { useQuery } from 'react-query'

const fetchUser = async (userId) => {
  const response = await fetch(`api/users/${userId}`)
  const data = await response.json()
  return data
}

function UserProfile({ userId }) {
  const queryConfig = {
    queryKey: ['user', userId],
    queryFn: () => fetchUser(userId),
    staleTime: 5000, // Thời gian hết hạn cache là 5 giây (cũ)
    cacheTime: 60000, // Thời gian lưu trữ cache là 1 phút

    onSuccess: (data) => {
      console.log('Fetch user data success:', data)
    },

    onError: (error) => {
      console.error('Fetch user data error:', error)
    }
  }

  const { data, isLoading, isError, error, refetch } = useQuery(queryConfig)

  if (isLoading) {
    return <div>Loading user profile...</div>
  }

  if (isError) {
    return <div>Error: {error.message}</div>
  }

  return (
    <div>
      <h1>User Profile</h1>
      <p>User ID: {userId}</p>
      <p>Name: {data.name}</p>
      <p>Email: {data.email}</p>
      <button onClick={() => refetch()}>Refresh</button>
    </div>
  )
}
```

- Trong ví dụ này, chúng ta sử dụng `useQuery` để lấy thông tin người dùng từ API dựa trên `userId`. Chúng ta cung cấp các tùy chọn và phương thức khác nhau trong đối tượng `queryConfig` để tùy chỉnh cách truy vấn hoạt động.

- `queryKey` được định nghĩa là một mảng `['user', userId]` để đại diện cho khóa truy vấn. Nếu `userId` thay đổi, truy vấn sẽ tự động được kích hoạt lại.

  - Trong React Query, `queryKey` được sử dụng để định danh và xác định truy vấn dữ liệu. Trong trường hợp của bạn, `queryKey` được đặt thành một mảng `['user', userId]`.

  - Phần tử đầu tiên của mảng, `'user'`, là một chuỗi định danh (identifier) cho truy vấn. Nó đại diện cho loại dữ liệu hoặc ngữ cảnh của truy vấn. Điều này giúp React Query quản lý và lưu trữ kết quả truy vấn dữ liệu trong bộ nhớ cache.

  - Phần tử thứ hai của mảng, `userId`, là một giá trị đại diện cho thông tin cụ thể mà truy vấn đang yêu cầu. Thông thường, đây là một giá trị duy nhất, ví dụ như ID của người dùng, được sử dụng để truy vấn dữ liệu từ máy chủ.

  - Khi bạn sử dụng `queryKey` trong React Query, nó giúp xác định một truy vấn dữ liệu cụ thể. Với cùng một `queryKey`, bạn có thể sử dụng nhiều hooks và hàm React Query khác nhau để thực hiện các hoạt động liên quan đến truy vấn này, ví dụ như `useQuery`, `useMutation`, `invalidateQueries`, và nhiều hàm khác.

  - Với `queryKey: ['user', userId]`, React Query sẽ sử dụng định danh truy vấn là `'user'` và thông tin cụ thể là `userId` để xác định và quản lý kết quả truy vấn dữ liệu liên quan đến người dùng có ID tương ứng.

  - Với việc sử dụng một cặp `[key, value]` như `['user', userId]`, bạn có thể định danh truy vấn và lấy dữ liệu tương ứng từ cache của React Query. Việc sử dụng định danh truy vấn giúp React Query tự động quản lý việc truy vấn dữ liệu và đồng bộ hóa kết quả giữa cache và máy chủ.

  - `'user'` là đường dẫn url hay sao ?

  👉 Trong ngữ cảnh của React Query, `'user'` không đại diện cho một đường dẫn (URL), mà là một chuỗi định danh (identifier) cho truy vấn dữ liệu.

  👉 Khi sử dụng React Query, chúng ta thường định nghĩa các truy vấn dữ liệu bằng cách sử dụng một chuỗi định danh để xác định loại dữ liệu hoặc ngữ cảnh của truy vấn. Điều này giúp React Query quản lý và lưu trữ kết quả của truy vấn trong bộ nhớ cache.

  👉 Ví dụ, trong trường hợp bạn muốn truy vấn dữ liệu người dùng từ máy chủ, bạn có thể sử dụng `'user'` làm định danh cho truy vấn này. Khi bạn gọi `useQuery('user', ...)`, React Query sẽ quản lý kết quả truy vấn người dùng và cung cấp các giá trị như `isLoading`, `isError`, `isSuccess` và `data` liên quan đến truy vấn này.

  👉 Vì vậy, `'user'` là một chuỗi định danh (identifier) cho truy vấn, không phải đường dẫn (`URL`). Đường dẫn sẽ được xác định thông qua cách gọi API hoặc kết hợp với định danh truy vấn để tạo thành một `URL` đầy đủ khi gửi yêu cầu đến máy chủ.

- ❌❌ khi mình truy vấn đến `user`, mà trong `user` đó có 10 người thì 10 người đó được lưu trong vô trong 1 `userId` hay sao ?

  - Khi bạn truy vấn dữ liệu người dùng và có 10 người trong kết quả truy vấn đó, thông tin của từng người dùng sẽ không được lưu trong một `userId` duy nhất. Thay vào đó, mỗi người dùng sẽ được lưu trữ và quản lý riêng lẻ trong cache của React Query.

  - Khi sử dụng React Query, mỗi mục dữ liệu trong kết quả truy vấn được lưu trữ theo khóa định danh (key) duy nhất trong bộ nhớ cache. Trong trường hợp của bạn, mỗi người dùng trong danh sách được trả về từ truy vấn dữ liệu sẽ có một khóa định danh riêng, không phải chỉ là một `userId` duy nhất.

  - Ví dụ, nếu bạn truy vấn dữ liệu người dùng và có 10 người trong kết quả, thì trong cache của React Query sẽ có 10 mục dữ liệu tương ứng với mỗi người dùng. Mỗi mục dữ liệu sẽ có một khóa định danh duy nhất, ví dụ `'user-1'`, `'user-2'`, ..., `'user-10'`. Điều này giúp React Query quản lý và truy xuất dữ liệu của từng người dùng một cách riêng lẻ.

  - Khi bạn truy cập hoặc thay đổi dữ liệu của một người dùng cụ thể, bạn có thể sử dụng khóa định danh tương ứng để thao tác với dữ liệu đó trong cache của React Query.

- `queryFn` là một hàm không đồng bộ để thực hiện truy vấn và lấy dữ liệu từ API. Trong trường hợp này, chúng ta sử dụng hàm `fetchUser` để lấy thông tin người dùng từ API dựa trên `userId`.
- `staleTime` là thời gian hết hạn và dữ liệu được coi là đã stale (cũ), trong trường hợp này là 5 giây. Sau thời gian này, nếu truy vấn được kích hoạt lại, React Query sẽ tự động gửi yêu cầu mới đến API để lấy dữ liệu mới nhất.
- `cacheTime` là thời gian lưu trữ cache, trong trường hợp này là 1 phút. Sau thời gian này, cache sẽ bị xóa khỏi bộ nhớ và truy vấn sẽ tự động gửi yêu cầu mới đến API để lấy dữ liệu mới nhất.
- `onSuccess` là một hàm được gọi khi truy vấn thành công. Trong ví dụ này, chúng ta log thông tin người dùng thành công vào console.
- `onError` là một hàm được gọi khi truy vấn gặp lỗi. Trong ví dụ này, chúng ta log lỗi truy vấn vào console.
- `refetch` là một phương thức được cung cấp bởi `useQuery` để gửi yêu cầu truy vấn lại và cập nhật dữ liệu. Chúng ta sử dụng nút "Refresh" để kích hoạt `refetch` khi người dùng nhấp vào.

- Với cấu hình truy vấn và các phương thức này, chúng ta có thể tùy chỉnh và sử dụng `useQuery` để lấy và quản lý dữ liệu từ API một cách linh hoạt trong ứng dụng React.

## Dưới đây là phần giải thích đoạn code trên:

- Đoạn code trên là một ví dụ về việc sử dụng `useQuery` trong React Query để lấy thông tin về một người dùng và hiển thị trên giao diện người dùng. Dưới đây là giải thích từng phần của mã:

1. Import thư viện và hàm `useQuery` từ React Query:

```jsx
import { useQuery } from 'react-query'
```

2. Định nghĩa hàm `fetchUser` để gửi yêu cầu lấy dữ liệu người dùng từ API:

```jsx
const fetchUser = async (userId) => {
  const response = await fetch(`api/users/${userId}`)
  const data = await response.json()
  return data
}
```

- Đoạn code trên định nghĩa một hàm `fetchUser` để lấy dữ liệu người dùng từ máy chủ sử dụng API. Dưới đây là giải thích từng dòng code:

  1. `const fetchUser = async (userId) => {`: Đây là việc bắt đầu khai báo một hàm bất đồng bộ (async) có tên `fetchUser` với tham số `userId`. Hàm này sẽ được sử dụng để truy vấn dữ liệu người dùng từ máy chủ.

  2. `const response = await fetch(api/users/${userId});`: Dòng này sử dụng hàm `fetch` để gửi một yêu cầu `GET` đến đường dẫn `api/users/${userId}`. Biến `response` sẽ chứa kết quả trả về từ máy chủ.

  3. `const data = await response.json();`: Dòng này sử dụng phương thức `json()` của đối tượng `response` để chuyển đổi dữ liệu trả về thành đối tượng JavaScript. Hàm này trả về một Promise, vì vậy chúng ta sử dụng từ khóa `await` để đợi việc chuyển đổi dữ liệu thành công.

  4. `return data;`: Dòng này trả về dữ liệu người dùng đã được chuyển đổi thành đối tượng JavaScript từ hàm `fetchUser`.

- Tổng quan, hàm `fetchUser` được sử dụng để gửi một yêu cầu truy vấn đến máy chủ để lấy dữ liệu người dùng dựa trên `userId`. Sau khi nhận được kết quả từ máy chủ, dữ liệu được chuyển đổi thành đối tượng JavaScript và trả về.

3. Định nghĩa component `UserProfile` nhận vào `userId` làm props:

```jsx
function UserProfile({ userId }) {
  // ...
}
```

4. Khai báo biến `queryConfig` để cấu hình truy vấn:

```jsx
const queryConfig = {
  queryKey: ['user', userId],
  queryFn: () => fetchUser(userId),
  staleTime: 5000,
  cacheTime: 60000,
  onSuccess: (data) => {
    console.log('Fetch user data success:', data)
  },
  onError: (error) => {
    console.error('Fetch user data error:', error)
  }
}
```

- Đoạn mã trên định nghĩa một đối tượng `queryConfig` chứa các cấu hình cho một truy vấn dữ liệu trong React Query. Dưới đây là giải thích từng thuộc tính trong `queryConfig`:

  - `queryKey: ['user', userId]`: `queryKey` xác định khóa của truy vấn dữ liệu. Trong trường hợp này, `queryKey` là một mảng chứa hai phần tử. Phần tử đầu tiên là chuỗi `'user'`, đại diện cho loại dữ liệu được truy vấn, và phần tử thứ hai là giá trị `userId` được sử dụng để xác định người dùng cụ thể.

  - `queryFn: () => fetchUser(userId)`: `queryFn` là một hàm được gọi khi truy vấn dữ liệu được thực hiện. Trong trường hợp này, `queryFn` sử dụng hàm `fetchUser` để lấy dữ liệu người dùng từ máy chủ, với `userId` được truyền vào như một tham số.

  - `staleTime: 5000`: `staleTime` xác định thời gian (tính bằng mili giây) sau khi dữ liệu trở thành cũ (stale). Khi dữ liệu trở thành cũ, React Query sẽ thực hiện một yêu cầu để lấy dữ liệu mới từ máy chủ. Trong trường hợp này, sau khi dữ liệu trở thành cũ trong vòng 5 giây (5000 mili giây), React Query sẽ tự động gửi yêu cầu để lấy dữ liệu mới.

  - `cacheTime: 60000`: `cacheTime` xác định thời gian (tính bằng mili giây) mà dữ liệu được lưu trong bộ nhớ cache của React Query trước khi bị xóa đi. Trong trường hợp này, dữ liệu sẽ được lưu trong cache trong vòng 1 phút (60000 mili giây) trước khi bị xóa.

  - `onSuccess: (data) => { console.log('Fetch user data success:', data) }`: `onSuccess` là một hàm callback được gọi khi truy vấn dữ liệu thành công. Trong trường hợp này, khi dữ liệu được lấy thành công từ máy chủ, hàm callback này sẽ được gọi và hiển thị một thông báo thành công trên `console` với dữ liệu được truy vấn (`data`).

  - `onError: (error) => { console.error('Fetch user data error:', error) }`: `onError` là một hàm callback được gọi khi truy vấn dữ liệu gặp lỗi. Trong trường hợp này, khi truy vấn dữ liệu gặp lỗi, hàm callback này sẽ được gọi và hiển thị một thông báo lỗi trên `console` với thông tin về lỗi (`error`).

- Tổng quan, đoạn mã trên định nghĩa các cấu hình cho một truy vấn dữ liệu trong React Query, bao gồm khóa truy vấn (`queryKey`), hàm truy vấn (`queryFn`), thời gian cũ hóa dữ liệu (`staleTime`), thời gian lưu trữ trong cache (`cacheTime`), và các hàm callback để xử lý kết quả truy vấn thành công (`onSuccess`) và lỗi (`onError`).

❌❌ onSuccess: (data) => { console.log('Fetch user data success:', data) }
❌❌ hãy viết lại hàm callback này bằng cách khác sử dụng function bình thường:

✅✅ Bạn có thể viết lại đoạn mã onSuccess bằng cách sử dụng function như sau:

```jsx
function handleSuccess(data) {
  console.log('Fetch user data success:', data)
}

const queryConfig = {
  // Các cấu hình khác...
  onSuccess: handleSuccess
}
```

- Trong đoạn mã trên, tôi đã tạo một hàm `handleSuccess` để xử lý khi dữ liệu truy vấn thành công. Sau đó, tôi gán hàm này cho thuộc tính `onSuccess` trong đối tượng `queryConfig`. Khi truy vấn dữ liệu thành công, hàm `handleSuccess` sẽ được gọi và thông tin dữ liệu (`data`) sẽ được log ra console.

- Lưu ý rằng tôi chỉ định tên hàm `handleSuccess` mà không gọi trực tiếp bằng cặp dấu ngoặc tròn `()`. Điều này đảm bảo rằng hàm chỉ được gọi khi xảy ra sự kiện thành công và không được gọi ngay từ đầu.

5. Sử dụng `useQuery` để thực hiện truy vấn và nhận kết quả trả về:

```jsx
const { data, isLoading, isError, error, refetch } = useQuery(queryConfig)
```

- Dòng code trên sử dụng hook `useQuery` từ `React Query` để thực hiện một truy vấn dữ liệu dựa trên `queryConfig` (cấu hình truy vấn). Khi sử dụng `useQuery`, chúng ta có thể trích xuất các thuộc tính quan trọng từ kết quả truy vấn thông qua việc gán chúng cho các biến tương ứng:

- Trong hook `useQuery` của `React Query`, các dữ liệu và chức năng sau đây đã được cung cấp sẵn:

  - `data`: Chứa dữ liệu trả về từ truy vấn thành công. Bạn có thể sử dụng `data` để hiển thị hoặc xử lý dữ liệu trong giao diện.
  - `isLoading`: Được đặt thành `true` trong quá trình truy vấn đang diễn ra, và `false` khi truy vấn hoàn thành hoặc gặp lỗi.
  - `isError`: Được đặt thành `true` nếu truy vấn gặp lỗi, và `false` nếu không có lỗi xảy ra.
  - `error`: Chứa thông tin về lỗi nếu có. Nếu `isError` là `true`, bạn có thể sử dụng `error` để xem và xử lý thông tin lỗi trong giao diện.
  - `refetch`: Một hàm được cung cấp bởi `React Query` để gửi lại yêu cầu truy vấn. Khi gọi `refetch()`, truy vấn sẽ được gửi lại và kết quả mới sẽ được cập nhật.

- Bằng cách trích xuất các biến này từ `useQuery`, bạn có thể sử dụng chúng để điều khiển và hiển thị trạng thái và dữ liệu truy vấn trong giao diện của bạn.

6. Xử lý các trạng thái truy vấn và hiển thị nội dung tương ứng trên giao diện người dùng:

```jsx
if (isLoading) {
  return <div>Loading user profile...</div>
}

if (isError) {
  return <div>Error: {error.message}</div>
}

return (
  <div>
    <h1>User Profile</h1>
    <p>User ID: {userId}</p>
    <p>Name: {data.name}</p>
    <p>Email: {data.email}</p>
    <button onClick={() => refetch()}>Refresh</button>
  </div>
)
```

- Nếu đang trong quá trình tải dữ liệu (`isLoading`), hiển thị thông báo "Loading user profile...".
- Nếu xảy ra lỗi trong quá trình truy vấn (`isError`), hiển thị thông báo lỗi và thông điệp lỗi tương ứng.
- Nếu truy vấn thành công, hiển thị thông tin người dùng bao gồm `ID`, `name` và `email`. Có một nút `"Refresh"` để gọi lại hàm `refetch` và lấy dữ liệu mới từ API.

- Tóm lại, đoạn code trên sử dụng `useQuery` để lấy thông tin người dùng từ API và hiển thị trên giao diện người dùng. Nó xử lý các trạng thái truy vấn và cung cấp khả năng làm mới dữ liệu thông qua hàm `refetch`.

## ❌❌ Lưu ý: hàm `refetch` này à mình không cần khai báo nhưng nó vẫn sẽ `refetch` lại cho mình à. Hàm `refetch` nó có sẵn mặc định trong react query hay sao ?

- Đúng, hàm `refetch` không cần khai báo mà nó đã được cung cấp sẵn bởi React Query. Khi bạn sử dụng `useQuery` để tạo truy vấn, React Query sẽ tự động tạo ra một số phương thức và thuộc tính cho đối tượng truy vấn trả về. Một trong số đó là phương thức `refetch`.

- Phương thức `refetch` được sử dụng để gửi lại truy vấn và cập nhật dữ liệu mới từ `server`. Khi bạn gọi `refetch()`, React Query sẽ thực hiện lại truy vấn theo cấu hình ban đầu và cập nhật dữ liệu mới vào `data` nếu truy vấn thành công. Điều này giúp bạn có thể làm mới dữ liệu một cách đơn giản và dễ dàng khi người dùng yêu cầu.

- Vì vậy, không cần phải khai báo riêng biệt, phương thức `refetch` đã được tích hợp trong `useQuery` và sẵn có để sử dụng. Bạn chỉ cần gọi `refetch()` khi cần làm mới dữ liệu truy vấn.

❌❌❌ Start: Giải thích về staleTime và cacheTime ❌❌❌

## ❌❌ Hãy hiểu rõ về staleTime và cacheTime ? Dưới đây là 1 ví dụ về staleTime và cacheTime ? Phải thật sự hiểu 2 thuộc tính này nhé, cái này rất quan trọng và cũng rất dễ lộn ?

- ví dụ `staleTime` có 2 giây và `cacheTime` 1 phút. Có nghĩa là khi `staleTime` hết hạn thì nó gọi đến `cacheTime`, mặc dù dữ liệu đó đã cũ nhưng nó vẫn phải dùng. `staleTime` bắt buộc phải dùng dữ liệu của `cacheTime` cho đến 1 phút. Sau khi quá 1 phút thì `cacheTime` gọi làm dữ liệu mới sau đó `staleTime` lại dùng dữ liệu của `cacheTime` có đúng như vậy không ? (ví dụ này hơi quằng)

- Không, hiểu lầm trong việc hiểu ý nghĩa của `staleTime` và `cacheTime`. Hãy xem lại ý nghĩa của hai thuộc tính này:

  - `staleTime`: Đây là thời gian mà dữ liệu trong cache vẫn được coi là "stale" (cũ) trước khi cần phải làm mới. Sau khi thời gian `staleTime` đã qua, React Query sẽ tự động thực hiện một truy vấn nền để làm mới dữ liệu và đảm bảo dữ liệu mới nhất được cung cấp.

  - `cacheTime`: Đây là thời gian tối đa mà dữ liệu truy vấn được lưu trữ trong bộ nhớ cache trước khi được coi là cũ và cần phải làm mới. Khi thời gian từ lần truy vấn gần nhất đến hiện tại vượt quá `cacheTime`, React Query sẽ thực hiện một truy vấn mới để lấy dữ liệu từ máy chủ thay vì sử dụng dữ liệu từ cache.

- Với ví dụ của bạn về `staleTime` là 2 giây và `cacheTime` là 1 phút, ý nghĩa của hai thuộc tính này là:

  - Khi truy vấn dữ liệu, nếu thời gian từ lần truy vấn gần nhất đến hiện tại vượt quá `staleTime` (2 giây trong trường hợp này), dữ liệu trong cache vẫn có thể được sử dụng và trả về cho các yêu cầu truy vấn mà không cần gửi yêu cầu mới đến máy chủ. Tuy nhiên, dữ liệu sẽ được đánh dấu là "stale" để chỉ ra rằng nó có thể không còn là dữ liệu mới nhất.

  - Sau khi thời gian từ lần truy vấn gần nhất đến hiện tại vượt quá `cacheTime` (1 phút trong trường hợp này), React Query sẽ thực hiện một truy vấn mới để lấy dữ liệu từ máy chủ thay vì sử dụng dữ liệu từ cache. Điều này đảm bảo rằng dữ liệu truy vấn được cung cấp là mới nhất và không bị quá cũ.

- Tuy nhiên, sau khi thời gian `cacheTime` đã qua (1 phút), `staleTime` (2 giây) không "gọi" lại `cacheTime`. `staleTime` chỉ định thời gian tối đa mà dữ liệu có thể được sử dụng mà không cần làm mới, trong khi `cacheTime` là thời gian tối đa mà dữ liệu được lưu trữ trong cache trước khi coi là cũ.

## ❌❌ Vậy thì dữ liệu của staleTime được lấy từ cacheTime hay sao ?

- Bạn đã thực sự hiểu lầm. Trong React Query, `staleTime` không lấy dữ liệu từ `cacheTime`. `staleTime` chỉ là một khoảng thời gian xác định sau khi mà dữ liệu trong cache vẫn được coi là "stale" (cũ) trước khi cần phải làm mới.

- Khi thời gian từ lần truy vấn gần nhất đến hiện tại vượt quá `staleTime`, dữ liệu trong cache vẫn có thể được sử dụng và trả về cho các yêu cầu truy vấn mà không cần gửi yêu cầu mới đến máy chủ. Tuy nhiên, dữ liệu được đánh dấu là "stale" để chỉ ra rằng nó có thể không còn là dữ liệu mới nhất.

- Sau khi thời gian `staleTime` đã qua, React Query sẽ tự động thực hiện một truy vấn nền để làm mới dữ liệu và đảm bảo dữ liệu mới nhất được cung cấp. Truy vấn này sẽ được gửi đến máy chủ để lấy dữ liệu mới, không liên quan đến `cacheTime`.

- Vì vậy, `staleTime` không dựa vào `cacheTime` để lấy dữ liệu. Chúng là hai thuộc tính riêng biệt trong React Query để quản lý việc làm mới dữ liệu từ cache.

❌❌❌ Finish: Giải thích về staleTime và cacheTime ❌❌❌

## Nếu useQuery dùng để GET thì useMutation dùng để POST, PUT, DELETE ? Hãy nêu sự khác nhau ?

- Đúng, trong React Query, `useMutation` được sử dụng để thực hiện các thao tác POST, PUT và DELETE (thay đổi dữ liệu) liên quan đến việc gửi yêu cầu tới server. Dưới đây là sự khác nhau chính giữa `useQuery` và `useMutation`:

1. `Tác động lên dữ liệu:` `useQuery` chỉ được sử dụng để truy vấn dữ liệu (GET) từ server, trong khi `useMutation` được sử dụng để thực hiện các thao tác thay đổi dữ liệu như tạo mới (POST), cập nhật (PUT) và xóa (DELETE) dữ liệu trên server.

2. `Hành động:` `useQuery` tạo ra một `instance` truy vấn dữ liệu, giúp ta lấy dữ liệu từ server và lưu trữ vào cache. Trong khi đó, `useMutation` tạo ra một `instance` thực hiện thao tác thay đổi dữ liệu, giúp ta gửi yêu cầu thay đổi dữ liệu tới server và xử lý kết quả trả về.

3. `Tính năng cung cấp:` `useQuery` cung cấp các tính năng như caching, tự động fetch lại dữ liệu khi cần thiết, background fetching, và nhiều tùy chọn khác liên quan đến truy vấn dữ liệu. Trong khi đó, `useMutation` cung cấp các tính năng như tự động làm mới cache sau khi thao tác thay đổi dữ liệu thành công, xử lý lỗi và thành công, và nhiều tùy chọn khác liên quan đến thao tác thay đổi dữ liệu.

4. `Callback functions:` Trong `useMutation`, ta có thể định nghĩa các callback functions như `onSuccess`, `onError`, `onSettled` để xử lý kết quả và các trạng thái của thao tác thay đổi dữ liệu.

- Tóm lại, `useMutation` là một hook trong React Query được sử dụng để thực hiện các thao tác thay đổi dữ liệu (POST, PUT, DELETE) và cung cấp các tính năng và tùy chọn liên quan đến thao tác thay đổi dữ liệu.

- Tiếp tục với sự khác nhau giữa `useQuery` và `useMutation` trong React Query:

1. `Tham số đầu vào:` Khi sử dụng `useQuery`, ta truyền `queryKey` và `queryFn` để xác định key của truy vấn và hàm để lấy dữ liệu từ server. Trong khi đó, khi sử dụng `useMutation`, ta truyền `mutationFn` để xác định hàm thực hiện thao tác thay đổi dữ liệu.

2. `Trạng thái và kết quả:` `useQuery` cung cấp các trạng thái như `isLoading`, `isError`, `isSuccess` để xác định trạng thái của truy vấn dữ liệu và `data` để lưu trữ kết quả trả về từ server. Trong khi đó, `useMutation` cung cấp các trạng thái như `isLoading`, `isError`, `isSuccess` để xác định trạng thái của thao tác thay đổi dữ liệu và không trả về kết quả từ server.

- Khi sử dụng hook `useQuery`, bạn có thể thực hiện truy vấn dữ liệu từ máy chủ.
- Khi sử dụng hook `useMutation`, bạn có thể thực hiện các thao tác thay đổi dữ liệu, chẳng hạn như tạo, cập nhật hoặc xóa dữ liệu trên máy chủ.

3. `Cập nhật cache:` Khi sử dụng `useQuery`, React Query tự động cập nhật cache khi có dữ liệu mới từ server hoặc khi cache hết hạn. Trong khi đó, khi sử dụng `useMutation`, ta cần xử lý cập nhật cache thủ công sau khi thao tác thay đổi dữ liệu thành công.

4. `Tối ưu hóa:` `useQuery` cung cấp các tính năng tối ưu hóa như `caching`, `background fetching` và `refetching` tự động dựa trên các tương tác của người dùng. Trong khi đó, `useMutation` tập trung vào việc thực hiện thao tác thay đổi dữ liệu một cách đáng tin cậy và xử lý kết quả tương ứng.

- Tóm lại, `useQuery` và `useMutation` là hai hook trong React Query được sử dụng cho mục đích khác nhau. `useQuery` được sử dụng để truy vấn dữ liệu (GET) từ server và cung cấp các tính năng liên quan đến truy vấn dữ liệu. `useMutation` được sử dụng để thực hiện các thao tác thay đổi dữ liệu (POST, PUT, DELETE) và cung cấp các tính năng liên quan đến thao tác thay đổi dữ liệu.

## Thêm student với useMutation trong React Query ?

- Để thêm một sinh viên mới sử dụng `useMutation` trong React Query, bạn có thể thực hiện các bước sau:

1. Định nghĩa hàm thực hiện thao tác thêm sinh viên (`POST`) lên server:

```jsx
const addStudent = async (newStudent) => {
  const response = await fetch('api/students', {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json'
    },
    body: JSON.stringify(newStudent)
  })

  if (!response.ok) {
    throw new Error('Failed to add student')
  }

  const data = await response.json()
  return data
}
```

2. Sử dụng `useMutation` để tạo một mutation hook để thực hiện thao tác thêm sinh viên:

```jsx
import { useMutation } from 'react-query'

const AddStudentForm = () => {
  const mutation = useMutation(addStudent)

  const handleSubmit = (event) => {
    event.preventDefault()
    const formData = new FormData(event.target)
    const newStudent = Object.fromEntries(formData.entries())
    mutation.mutate(newStudent)
  }

  return (
    <form onSubmit={handleSubmit}>
      <input type='text' name='name' placeholder='Name' required />
      <input type='text' name='age' placeholder='Age' required />
      <button type='submit' disabled={mutation.isLoading}>
        {mutation.isLoading ? 'Adding...' : 'Add Student'}
      </button>
      {mutation.isError && <div>Error: {mutation.error.message}</div>}
      {mutation.isSuccess && <div>Student added successfully!</div>}
    </form>
  )
}
```

- Trong ví dụ trên, `mutation` là một object được trả về từ hook `useMutation`. Bạn có thể sử dụng `mutation.mutate` để kích hoạt thao tác thêm sinh viên khi form được submit. `mutation.isLoading`, `mutation.isError`, và `mutation.isSuccess` là các trạng thái để xử lý giao diện khi thao tác đang diễn ra, gặp lỗi, hoặc thành công.

- Lưu ý rằng, việc xử lý cập nhật cache sau khi thêm sinh viên thành công cần phụ thuộc vào cấu hình và quyết định của bạn. Bạn có thể sử dụng các phương thức như `queryClient.invalidateQueries` để cập nhật cache cho danh sách sinh viên hoặc trang chi tiết sinh viên.

- Đây chỉ là một ví dụ cơ bản về việc sử dụng `useMutation` để thêm sinh viên. Bạn có thể tùy chỉnh và bổ sung thêm theo nhu cầu của ứng dụng của mình.

## Giải thích chi tiết đoạn code trên:

```jsx
const addStudent = async (newStudent) => {
  const response = await fetch('api/students', {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json'
    },
    body: JSON.stringify(newStudent)
  })

  if (!response.ok) {
    throw new Error('Failed to add student')
  }

  const data = await response.json()
  return data
}
```

- Đoạn code trên định nghĩa một hàm `addStudent` để thực hiện thao tác thêm sinh viên mới (POST) lên server thông qua API endpoint `'api/students`'.

- Hàm `addStudent` sử dụng `fetch` để gửi một request POST đến endpoint `'api/students'` với các thông tin của sinh viên mới được đưa vào trong body của request dưới dạng JSON. Để thực hiện điều này, `fetch` được gọi với các tham số như sau:

- `method: 'POST':` Thuộc tính `method` xác định phương thức HTTP được sử dụng trong yêu cầu. Trong trường hợp này, phương thức được sử dụng là POST. Phương thức POST được sử dụng để gửi dữ liệu từ client lên máy chủ để tạo hoặc cập nhật tài nguyên.

- `headers: {'Content-Type': 'application/json'}:` Thuộc tính `headers` định nghĩa các tiêu đề (headers) của yêu cầu HTTP. Trong trường hợp này, đoạn mã chỉ định một tiêu đề `'Content-Type'` với giá trị `'application/json'`. Tiêu đề này cho biết rằng dữ liệu trong yêu cầu được gửi dưới dạng JSON. Điều này giúp máy chủ hiểu cách xử lý và phân tích nội dung yêu cầu.

- `body: JSON.stringify(newStudent):` Thuộc tính `body` định nghĩa nội dung của yêu cầu HTTP. Trong trường hợp này, `JSON.stringify(newStudent)` được sử dụng để chuyển đổi đối tượng (object) `newStudent` thành chuỗi JSON (JSON String). Chuỗi JSON này sau đó được gán cho thuộc tính `body`. Điều này đảm bảo rằng dữ liệu của `newStudent` được gửi đi dưới dạng chuỗi JSON trong yêu cầu POST.

- Khi yêu cầu HTTP POST này được gửi đi, nó sẽ chứa một tiêu đề `'Content-Type': 'application/json'` để chỉ định kiểu nội dung là JSON và một phần body chứa dữ liệu của `newStudent` đã được chuyển đổi thành chuỗi JSON.

- `if (!response.ok):` Đây là một câu điều kiện kiểm tra xem phản hồi từ máy chủ có thành công hay không. Phản hồi được coi là thành công nếu trạng thái HTTP là trong khoảng từ 200 đến 299 (bao gồm cả 200 và 299). Điều kiện `!response.ok` kiểm tra xem trạng thái HTTP có nằm ngoài khoảng thành công hay không.

- `throw new Error('Failed to add student'):` Nếu phản hồi không thành công, một ngoại lệ (exception) được ném bằng cách sử dụng `throw`. Trong trường hợp này, một đối tượng lỗi mới được tạo với thông báo `'Failed to add student'`. Ngoại lệ này sẽ được truyền cho phần xử lý lỗi bên ngoài hàm hiện tại để xử lý tiếp theo.

- `const data = await response.json():` Nếu phản hồi thành công, dữ liệu trong phản hồi được đọc và chuyển đổi từ định dạng JSON sang đối tượng JavaScript bằng cách sử dụng phương thức `response.json()`. Kết quả của phương thức này là một lời hứa (promise) được giải quyết (resolved) khi dữ liệu JSON đã được chuyển đổi thành đối tượng JavaScript.

- `return data:` Kết quả của hàm là đối tượng dữ liệu (`data`). Nếu mọi thứ thành công, dữ liệu này sẽ được trả về cho người gọi hàm để sử dụng tiếp.

- Tóm lại, đoạn mã trên kiểm tra và xử lý phản hồi từ máy chủ sau một yêu cầu HTTP. Nếu phản hồi thành công, nó trả về dữ liệu từ phản hồi dưới dạng đối tượng JavaScript. Nếu phản hồi không thành công, nó ném một ngoại lệ để xử lý lỗi.

## ❌❌ Lưu ý: Tại sao không dùng `response.parse()` mà lại sử dụng `response.json()`. Trong khi 2 dạng đó đều trả về dạng đối tượng jsvascript ?

- Thật đúng là có một sự khác biệt giữa `response.parse()` và `response.json()`, và trong hầu hết các trường hợp, chúng ta sẽ sử dụng `response.json()` để chuyển đổi phản hồi từ JSON sang đối tượng JavaScript. Dưới đây là sự khác biệt chính giữa hai phương thức này:

1. `response.parse():` Phương thức `parse()` không tồn tại trong đối tượng `response` của một yêu cầu HTTP. Thay vào đó, phương thức `parse()` là một phương thức của đối tượng `JSON` trong JavaScript. Nó được sử dụng để chuyển đổi một chuỗi JSON thành một đối tượng JavaScript.

2. `response.json():` Phương thức `json()` là một phương thức của đối tượng `response` trong JavaScript. Khi gọi phương thức này trên đối tượng `response`, nó trả về một lời hứa (promise) mà khi giải quyết (resolved), nó trả về dữ liệu JSON được chuyển đổi thành đối tượng JavaScript.

- Sự khác biệt chính giữa hai phương thức này là `response.json()` không chỉ chuyển đổi JSON thành đối tượng JavaScript, mà nó cũng xử lý việc đọc và xử lý dữ liệu từ phản hồi HTTP. Nó tự động đọc và chuyển đổi phản hồi thành dữ liệu JSON và trả về một hứa chứa đối tượng JavaScript đã chuyển đổi.

- Vì vậy, khi làm việc với phản hồi từ một yêu cầu HTTP, chúng ta sử dụng `response.json()` để thuận tiện đọc và chuyển đổi dữ liệu JSON thành đối tượng JavaScript.

```jsx
import { useMutation } from 'react-query'

const AddStudentForm = () => {
  const mutation = useMutation(addStudent)

  const handleSubmit = (event) => {
    event.preventDefault()
    const formData = new FormData(event.target)
    const newStudent = Object.fromEntries(formData.entries())
    mutation.mutate(newStudent)
  }

  return (
    <form onSubmit={handleSubmit}>
      <input type='text' name='name' placeholder='Name' required />
      <input type='text' name='age' placeholder='Age' required />
      <button type='submit' disabled={mutation.isLoading}>
        {mutation.isLoading ? 'Adding...' : 'Add Student'}
      </button>
      {mutation.isError && <div>Error: {mutation.error.message}</div>}
      {mutation.isSuccess && <div>Student added successfully!</div>}
    </form>
  )
}
```

- Đoạn code trên định nghĩa một component `AddStudentForm` sử dụng `useMutation` từ React Query để thực hiện thao tác thêm sinh viên mới.

- Trong component `AddStudentForm`, hàm `useMutation` được gọi với đối số là hàm `addStudent` (đã được định nghĩa trước đó) để tạo ra một đối tượng `mutation`. Đối tượng `mutation` chứa các phương thức và trạng thái liên quan đến việc thực hiện mutation (POST) và xử lý kết quả.

- Trong hàm `handleSubmit`, khi người dùng gửi form bằng cách nhấn nút `submit`, sự kiện `submit` được kích hoạt. Hàm `handleSubmit` được gọi và truyền vào đối tượng sự kiện event như tham số.

- Để tránh việc trình duyệt gửi request và refresh trang, hàm `event.preventDefault()` được gọi để ngăn chặn hành vi mặc định của form.

- Sau đó, thông tin từ form được lấy bằng cách tạo một đối tượng `formData` từ `event.target`, đại diện cho form được gửi đi. `FormData` là một đối tượng tích hợp sẵn trong JavaScript cho phép truy cập và xử lý dữ liệu form.

- Tiếp theo, `formData.entries()` trả về một iterator chứa tất cả cặp khóa-giá trị (key-value) trong form data. `Object.fromEntries()` được sử dụng để chuyển đổi iterator này thành một đối tượng JSON `newStudent`, trong đó khóa là tên của các trường form và giá trị là giá trị đã nhập.

- Cuối cùng, `mutation.mutate(newStudent)` được gọi để kích hoạt quá trình mutation (POST) với đối tượng `newStudent` là dữ liệu cần thêm. Quá trình này sẽ được xử lý bởi React Query, bao gồm gửi request lên server, xử lý kết quả và cập nhật cache nếu cần.

- Đoạn code trên giúp kết nối form và việc thực hiện thao tác thêm sinh viên mới thông qua `useMutation`, và cho phép xử lý các tương tác với form và quá trình mutation một cách dễ dàng trong React.

## ❌❌ Hãy định nghĩa phương thức entries() trong JavaScript là gì ?

- Phương thức `entries()` là một phương thức của đối tượng `Object` trong JavaScript. Nó được sử dụng để trả về một mảng chứa các cặp khóa-giá trị (`key-value`) của một đối tượng.

- Khi áp dụng phương thức `entries()` lên một đối tượng, nó sẽ tạo ra một mảng các cặp khóa-giá trị, trong đó mỗi cặp bao gồm một khóa (key) và giá trị (value) của thuộc tính trong đối tượng.

- Ví dụ, xét một đối tượng `person` như sau:

```jsx
const person = {
  name: 'John',
  age: 30,
  occupation: 'Engineer'
}
```

- Khi áp dụng `Object.entries(person)`, kết quả sẽ là một mảng chứa các cặp khóa-giá trị như sau:

```jsx
;[
  ['name', 'John'],
  ['age', 30],
  ['occupation', 'Engineer']
]
```

- Mỗi phần tử trong mảng là một mảng con chứa một cặp khóa-giá trị, trong đó phần tử đầu tiên là khóa và phần tử thứ hai là giá trị tương ứng.

- Phương thức `entries()` rất hữu ích khi bạn muốn lặp qua các thuộc tính của một đối tượng và thực hiện các thao tác trên từng cặp khóa-giá trị trong đối tượng đó.

## ❌❌ Ví dụ về entries() trong JavaScript ?

- Để minh họa cách sử dụng phương thức `entries()`, hãy xem xét ví dụ sau:

```jsx
const person = {
  name: 'John',
  age: 30,
  occupation: 'Engineer'
}

// Sử dụng phương thức entries() để lặp qua các cặp khóa-giá trị trong đối tượng person
for (const [key, value] of Object.entries(person)) {
  console.log(`${key}: ${value}`)
}
```

- Đầu tiên, chúng ta có một đối tượng `person` đại diện cho thông tin về một người. Chúng ta muốn lặp qua các thuộc tính của đối tượng này và hiển thị cặp khóa-giá trị tương ứng.

- Bằng cách sử dụng phương thức `Object.entries(person)`, chúng ta chuyển đổi đối tượng `person` thành một mảng chứa các cặp khóa-giá trị.

- Sau đó, chúng ta sử dụng một vòng lặp `for...of` để lặp qua mảng các cặp khóa-giá trị. Trong mỗi lần lặp, chúng ta gán khóa và giá trị tương ứng cho các biến `key` và `value`. Sau đó, chúng ta hiển thị cặp khóa-giá trị bằng cách sử dụng `console.log()`.

- Kết quả của đoạn mã trên sẽ là:

```jsx
name: John
age: 30
occupation: Engineer
```

- Mỗi dòng đại diện cho một cặp khóa-giá trị trong đối tượng `person`, trong đó `key` là khóa (ví dụ: 'name', 'age', 'occupation') và `value` là giá trị tương ứng (ví dụ: 'John', 30, 'Engineer').

- Điều này cho thấy chúng ta đã lặp qua các thuộc tính của đối tượng `person` và hiển thị cặp khóa-giá trị tương ứng.

## Xử lý lỗi 422 khi submit form bị lỗi trong React Query ?

- Để xử lý lỗi 422 khi submit form bị lỗi trong React Query, bạn có thể sử dụng thuộc tính `onError` của đối tượng mutation trả về bởi `useMutation`. Dưới đây là một ví dụ về cách xử lý lỗi 422:

```jsx
import { useMutation } from 'react-query'

const AddStudentForm = () => {
  const mutation = useMutation(addStudent, {
    onError: (error) => {
      if (error.response?.status === 422) {
        // Xử lý lỗi 422 ở đây
        // Ví dụ: Hiển thị thông báo lỗi hoặc cập nhật trạng thái lỗi
      }
    }
  })

  const handleSubmit = (event) => {
    event.preventDefault()
    const formData = new FormData(event.target)
    const newStudent = Object.fromEntries(formData.entries())
    mutation.mutate(newStudent)
  }

  // ...
}
```

## Reset error và data trong React Query ?

- Trong React Query, để reset lỗi (`error`) và dữ liệu (`data`) của một truy vấn, bạn có thể sử dụng các phương thức có sẵn trong đối tượng truy vấn được trả về từ `useQuery`. Dưới đây là một số phương thức để reset lỗi và dữ liệu trong React Query:

1. Reset lỗi (`error`):

- Sử dụng phương thức `resetErrorBoundary` để đặt lại lỗi cho một truy vấn cụ thể:

```jsx
import { useQuery } from 'react-query'

const { resetErrorBoundary } = useQuery(queryKey, queryFn)

// Đặt lại lỗi cho truy vấn
resetErrorBoundary()
```

- Sử dụng phương thức `reset` để đặt lại lỗi cho tất cả các truy vấn trong cache:

```jsx
import { useQueryClient } from 'react-query'

const queryClient = useQueryClient()

// Đặt lại lỗi cho tất cả các truy vấn trong cache
queryClient.resetErrors()
```

2. Reset dữ liệu (`data`):

- Sử dụng phương thức `reset` để đặt lại dữ liệu cho một truy vấn cụ thể:

```jsx
import { useQuery } from 'react-query'

const { reset } = useQuery(queryKey, queryFn)

// Đặt lại dữ liệu cho truy vấn
reset()
```

- Sử dụng phương thức `removeQueries` để xóa dữ liệu và truy vấn khỏi cache:

```jsx
import { useQueryClient } from 'react-query'

const queryClient = useQueryClient()

// Xóa dữ liệu và truy vấn khỏi cache
queryClient.removeQueries(queryKey)
```

- Lưu ý rằng việc reset lỗi và dữ liệu chỉ ảnh hưởng trong phạm vi của một truy vấn cụ thể hoặc tất cả các truy vấn trong cache.

## Reset lại lỗi có nghĩa là xoá hết tất cả các lỗi từ trước đó hả ?

- Không, khi chúng ta nói về việc `reset lại lỗi` trong React Query, điều đó chỉ áp dụng cho các lỗi liên quan đến truy vấn mà bạn đang thực hiện. Việc reset lỗi sẽ xóa lỗi hiện tại và cho phép truy vấn được thực thi lại.

- Khi sử dụng phương thức `resetErrorBoundary` hoặc `reset` trong React Query, nó chỉ đặt lại lỗi cho truy vấn cụ thể mà bạn đang làm việc, không ảnh hưởng đến các lỗi từ các truy vấn khác hoặc các lỗi đã xảy ra trong quá khứ.

- Để xoá hết tất cả các lỗi từ trước đó trong quá khứ trong React Query, bạn có thể sử dụng phương thức `queryClient.resetErrors()`. Phương thức này sẽ xóa toàn bộ các lỗi của tất cả các truy vấn trong `cache`, không chỉ riêng truy vấn hiện tại.

- Vì vậy, việc reset lỗi chỉ tác động đến truy vấn cụ thể hoặc tất cả các truy vấn trong `cache`, không ảnh hưởng đến các lỗi từ trước đó của các truy vấn khác.

## Reset lại data có nghĩa là xoá hết tất cả các dữ từ trước đó và trong cache lun hả ?

- Khi bạn sử dụng phương thức `reset` trong React Query để `reset` lại dữ liệu của một truy vấn, nó sẽ xoá dữ liệu của truy vấn đó khỏi `cache`. Điều này có nghĩa là dữ liệu của truy vấn sẽ không còn tồn tại trong `cache` và khi truy vấn được thực hiện lại, dữ liệu sẽ được fetch từ nguồn dữ liệu gốc.

- Tuy nhiên, việc `reset` lại dữ liệu chỉ ảnh hưởng đến truy vấn cụ thể mà bạn gọi phương thức `reset` và không ảnh hưởng đến các truy vấn khác. Nếu bạn muốn xoá hết tất cả các dữ liệu trong `cache` của tất cả các truy vấn bao gồm dữ liệu trước đó, bạn có thể sử dụng phương thức `queryClient.clear()` để làm điều đó.

- Vì vậy, khi bạn `reset` lại dữ liệu của một truy vấn bằng cách sử dụng `reset`, nó chỉ xoá dữ liệu của truy vấn đó khỏi `cache` và không ảnh hưởng đến các dữ liệu của truy vấn khác trong `cache`.

## Reset formState với mutationAsync trong React Query ?

- Trong React Query, để reset formState sau khi thực hiện một mutation (POST, PUT, DELETE) bằng cách sử dụng `mutationAsync`, bạn có thể thực hiện các bước sau:

1. Định nghĩa một biến thể hiện trạng thái của form, ví dụ: `const [formData, setFormData] = useState(initialFormData);`. `initialFormData` là giá trị ban đầu của form.

2. Trong hàm `handleSubmit` của form, sau khi gọi `mutationAsync`, bạn có thể reset formState bằng cách gán lại giá trị ban đầu cho biến `formData`, ví dụ: `setFormData(initialFormData);`.

- Dưới đây là một ví dụ minh họa:

```jsx
import { useMutation } from 'react-query'

const initialFormData = {
  // Khởi tạo giá trị ban đầu của form
  // ...
}

const [formData, setFormData] = useState(initialFormData)

const AddStudentForm = () => {
  const mutation = useMutation(addStudent)

  const handleSubmit = async (event) => {
    event.preventDefault()
    const formData = new FormData(event.target)
    const newStudent = Object.fromEntries(formData.entries())

    try {
      await mutation.mutationAsync(newStudent)
      // Reset formState sau khi thành công
      setFormData(initialFormData)
    } catch (error) {
      // Xử lý lỗi khi mutation thất bại
    }
  }

  return <form onSubmit={handleSubmit}>{/* Các trường form */}</form>
}
```

- Trong ví dụ trên, sau khi mutation thành công, chúng ta gọi `setFormData(initialFormData)` để đặt lại giá trị ban đầu cho form. Điều này sẽ làm cho form trở về trạng thái rỗng hoặc trạng thái ban đầu của form, tùy thuộc vào giá trị được khởi tạo ban đầu trong `initialFormData`.

- Lưu ý rằng `setFormData` là một hàm từ hook `useState`, và bạn cần phải định nghĩa biến `formData` và hàm `setFormData` để sử dụng nó.

## `const formData = new FormData(event.target)`. FormData có sẵn hay sao mà tôi không thấy khai báo ?

- `FormData` là một đối tượng có sẵn trong JavaScript và không cần phải khai báo hoặc import từ các thư viện bên ngoài. Đối tượng `FormData` cho phép bạn tạo và quản lý dữ liệu form dễ dàng trong JavaScript.

- Trong ví dụ của chúng ta, `FormData` được sử dụng để tạo một đối tượng formData từ sự kiện `submit` của form (`event.target`). Khi truyền `event.target` vào constructor của `FormData`, nó sẽ tự động trích xuất các giá trị từ các trường form và tạo một đối tượng `FormData` tương ứng.

- Sau đó, chúng ta sử dụng formData để tạo đối tượng `newStudent` thông qua phương thức `Object.fromEntries(formData.entries())`. Điều này chuyển đổi đối tượng `FormData` thành một đối tượng JavaScript thông thường với các cặp key-value tương ứng với các trường form.

- Vì `FormData` là một đối tượng có sẵn trong JavaScript, bạn có thể sử dụng nó mà không cần khai báo hoặc import từ các thư viện bên ngoài.

## Đây là Docs của Được Dev:

Nếu useQuery dùng để GET thì useMutation dùng để POST, PUT, DELETE. Video này tiếp nối video lần trước chúng ta sẽ thực hiện chức năng thêm học sinh 🎉

💓Kiến thức các bạn sẽ được học trong video này:

🎉 Cách phân trang và tối ưu UX với React Query
🎉 Những state quan trọng trong React Query
🎉 Cơ chế caching của React Query

🕰️Nội dung chính

```jsx
00:00 - add student với useMutation
28:38 - Xử lý lỗi 422 khi submit form bị lỗi
48:20 - reset error và data
50:45 - reset formState với mutationAsync
```
